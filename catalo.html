<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Beni-Wealth — Pool (Player vs System)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#f3fbf6; /* light */
      --primary:#0b6b3a; /* beni-wealth green */
      --accent:#0b6b3a;
      --card:#ffffff;
      --muted:#666;
      --rail:#2a5a3b;
      --shadow: 0 8px 30px rgba(10,10,10,.08);
    }
    html,body{height:100%;margin:0;font-family:Poppins,system-ui,Segoe UI,Roboto,Arial;color:#123}
    body{background:linear-gradient(180deg,var(--bg) 0%, #e6f7ee 100%);display:flex;justify-content:center;padding:12px}
    .wrap{width:100%;max-width:980px;background:var(--card);border-radius:14px;box-shadow:var(--shadow);overflow:hidden}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #eef6ef}
    header h1{font-size:16px;margin:0;color:var(--primary)}
    header .controls{display:flex;gap:8px;align-items:center}
    main{display:flex;gap:16px;padding:12px}

    /* Game area */
    #game-area{flex:1;display:flex;flex-direction:column;align-items:center}
    .table-wrap{width:100%;max-width:760px}
    canvas{width:100%;height:auto;background:#0a2b18;border-radius:8px;box-shadow:inset 0 0 40px rgba(0,0,0,.6);touch-action:none}

    /* Sidebar */
    .sidebar{width:320px;padding:8px}
    .card{background:#fff;border-radius:10px;padding:10px;margin-bottom:12px;border:1px solid #f0f6f0}
    .muted{color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .small{font-size:13px}
    .note{font-size:13px;color:#444}

    /* mobile adjustments */
    @media (max-width:820px){
      main{flex-direction:column}
      .sidebar{width:100%;order:2}
      .table-wrap{order:1}
      .card{margin-bottom:10px}
    }

    /* controls large for touch */
    .controls button, .card button{padding:12px;border-radius:10px}
    .power-display{font-weight:600;color:var(--primary)}
    .aim-nudge{display:flex;gap:6px}
    .icon-btn{background:#f4fff7;border:1px solid #e6f6ec;padding:8px;border-radius:8px;cursor:pointer}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Beni-Wealth — Pool (Player vs System)</h1>
      <div class="controls">
        <div class="muted small">Fairness: <strong>50%</strong></div>
        <button id="newGameBtn">New Game</button>
      </div>
    </header>

    <main>
      <div id="game-area">
        <div class="table-wrap">
          <canvas id="table" width="760" height="420" aria-label="Pool table"></canvas>
        </div>

        <div style="width:100%;max-width:760px;display:flex;justify-content:space-between;align-items:center;margin-top:10px;gap:8px;">
          <div class="muted small">Turn: <strong id="turnLabel">Player</strong></div>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="muted small">Aim assist</label>
            <input type="checkbox" id="aimAssist" checked />
          </div>
        </div>

      </div>

      <aside class="sidebar">
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <div>
              <div class="muted small">Player</div>
              <div id="playerScore">Balls potted: 0</div>
            </div>
            <div>
              <div class="muted small">System</div>
              <div id="aiScore">Balls potted: 0</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="small muted">Shot Controls (mobile-friendly)</div>
          <div style="margin-top:10px;display:flex;flex-direction:column;gap:8px">
            <div class="row" style="justify-content:space-between;align-items:center">
              <div class="small">Power: <span class="power-display" id="powerVal">30</span></div>
              <input id="power" type="range" min="8" max="55" value="30" style="flex:1" />
            </div>

            <div class="row" style="justify-content:space-between;align-items:center">
              <div class="small">Angle (deg): <span id="angleVal">0</span></div>
              <div class="aim-nudge">
                <button class="icon-btn" id="angleDown">◀</button>
                <button class="icon-btn" id="angleUp">▶</button>
              </div>
            </div>

            <div class="row" style="justify-content:space-between">
              <button id="setShot">Set Shot (tap where to aim)</button>
              <button id="shootBtn">Shoot</button>
            </div>

            <div class="note">How it works: Tap anywhere on the table to set aim direction. Use the power slider and angle nudge for fine control. Drag from the cue ball still works for quick shots.</div>
          </div>
        </div>

        <div class="card">
          <div class="small muted">Game Options</div>
          <div style="margin-top:8px" class="row">
            <label class="small">AI Skill</label>
            <select id="aiSkill">
              <option value="0.5">Balanced (50%)</option>
              <option value="0.35">Easier</option>
              <option value="0.7">Harder</option>
            </select>
          </div>
          <div style="margin-top:8px" class="row">
            <button id="toggleAI">Start AI Turn</button>
            <button id="downloadReplay">Download Replay</button>
          </div>
        </div>

        <div class="card">
          <div class="small muted">Firebase (Beni-Wealth)</div>
          <div class="note" style="margin-top:6px">Prototype initializes Firebase for Beni-Wealth but does not write data: projectId = <strong>beni-wealths</strong></div>
        </div>

      </aside>
    </main>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    // analytics optional
    import { getAnalytics } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-analytics.js';
    import { getFirestore } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = initializeApp(firebaseConfig);
    try{ getAnalytics(app); }catch(e){ /* analytics may fail in some environments */ }
    const db = getFirestore(app);
    console.log('Firebase (Beni-Wealth) initialized (prototype)');

    // ---- Responsive & improved pool implementation (no spin, improved aiming controls) ----
    const canvas = document.getElementById('table');
    const ctx = canvas.getContext('2d');

    // HiDPI scaling
    function fitCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor((rect.width * 0.55) * dpr); // keep aspect ratio ~760x420
      canvas.style.height = (rect.width * 0.55) + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    // initial sizing
    window.addEventListener('resize', ()=>{ fitCanvas(); });
    // ensure canvas container has width set so fitCanvas can read it
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(fitCanvas,50); });

    // table geometry (in CSS pixels)
    let W = 760, H = 420; // logical baseline; we will scale drawing based on actual canvas size

    const pocketRadius = 18;
    const ballRadius = 9;
    const friction = 0.988; // per frame
    const padding = 30;

    let balls = [];
    let cueBallId = 0;
    let isAiming=false, aimStart=null, aimEnd={x:0,y:0};

    // improved controls
    const powerInput = document.getElementById('power');
    const powerVal = document.getElementById('powerVal');
    const angleVal = document.getElementById('angleVal');
    const angleUp = document.getElementById('angleUp');
    const angleDown = document.getElementById('angleDown');
    const setShotBtn = document.getElementById('setShot');
    const shootBtn = document.getElementById('shootBtn');

    let queuedAim = null; // {angle, power} when set by tapping

    powerInput.addEventListener('input', ()=>{ powerVal.textContent = powerInput.value; });

    let currentAngle = 0;
    function setAngle(a){ currentAngle = ((a % 360) + 360) % 360; angleVal.textContent = Math.round(currentAngle); }
    angleUp.addEventListener('click', ()=>{ setAngle(currentAngle + 1); });
    angleDown.addEventListener('click', ()=>{ setAngle(currentAngle - 1); });

    setShotBtn.addEventListener('click', ()=>{
      // instruct user to tap on table to set aim
      setTimeout(()=>{ alert('Tap anywhere on the table to set aim direction from the cue ball.'); },50);
      queuedAim = null;
    });

    shootBtn.addEventListener('click', ()=>{ performShootFromControls(); });

    // UI state
    let currentTurn = 'player';
    let allowPlayerShot = true;
    let replay = [];

    const pockets = [
      {x: padding, y: padding},
      {x: 380, y: padding},
      {x: W-padding, y: padding},
      {x: padding, y: H-padding},
      {x: 380, y: H-padding},
      {x: W-padding, y: H-padding}
    ];

    function resetTable(){
      // set base logical size
      W = 760; H = 420;
      balls = [];
      balls.push({id:0,x:160,y:H/2,vx:0,vy:0,r:ballRadius,color:'#ffffff',active:true});
      const rack = [ {x:520,y:H/2-18},{x:538,y:H/2},{x:538,y:H/2-36},{x:556,y:H/2-18},{x:556,y:H/2+18},{x:574,y:H/2} ];
      for(let i=0;i<rack.length;i++){
        balls.push({id:i+1,x:rack[i].x,y:rack[i].y,vx:0,vy:0,r:ballRadius,color:'#ffcc00',active:true});
      }
      cueBallId = 0;
      document.getElementById('playerScore').textContent = 'Balls potted: 0';
      document.getElementById('aiScore').textContent = 'Balls potted: 0';
      currentTurn = 'player'; allowPlayerShot = true; updateTurnLabel(); replay = [];
      fitCanvas();
    }

    function worldToScreen(v){
      // drawing is scaled to fit CSS width; compute scale factor
      const rect = canvas.getBoundingClientRect();
      const scale = rect.width / 760; return {x: v.x * scale, y: v.y * scale};
    }

    function screenToWorld(x,y){
      const rect = canvas.getBoundingClientRect();
      const scale = rect.width / 760; return {x: x/scale, y: y/scale};
    }

    function drawTable(){
      const rect = canvas.getBoundingClientRect();
      const scale = rect.width / 760;
      // clear (use CSS pixels via ctx clearing with identity transform)
      ctx.clearRect(0,0,rect.width,rect.height);
      // draw scaled
      ctx.save(); ctx.scale(scale,scale);
      // green felt
      ctx.fillStyle = '#0a2b18'; ctx.fillRect(0,0,W,H);
      // rails
      ctx.fillStyle = '--rail';
      ctx.fillStyle = '#2a5a3b';
      ctx.fillRect(0,0,W,padding);
      ctx.fillRect(0,H-padding,W,padding);
      ctx.fillRect(0,0,padding,H);
      ctx.fillRect(W-padding,0,padding,H);
      // pockets
      for(const p of pockets){ ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(p.x,p.y,pocketRadius,0,Math.PI*2); ctx.fill(); }

      // predicted aim/ghost ball (if aiming or queued)
      const aimAssistOn = document.getElementById('aimAssist').checked;
      if(aimAssistOn){
        drawAimPrediction();
      }

      // balls
      for(const b of balls){ if(!b.active) continue; ctx.beginPath(); ctx.fillStyle = b.color; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#222'; ctx.lineWidth=1; ctx.stroke(); }

      // aiming line when dragging for quick shots
      if(isAiming){
        const cue = balls.find(x=>x.id===cueBallId);
        ctx.beginPath(); ctx.moveTo(cue.x,cue.y); ctx.lineTo(aimEnd.x,aimEnd.y);
        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth=2; ctx.setLineDash([8,6]); ctx.stroke(); ctx.setLineDash([]);
      }

      ctx.restore();
    }

    function drawAimPrediction(){
      const cue = balls.find(b=>b.id===cueBallId && b.active);
      if(!cue) return;
      // choose best target: current queuedAim angle/power or ghost from heuristic: find nearest object and pocket
      if(queuedAim){
        // draw line from cue showing selected angle
        const ang = queuedAim.angle*Math.PI/180;
        const len = 300;
        ctx.save(); ctx.scale(canvas.getBoundingClientRect().width/760, canvas.getBoundingClientRect().width/760);
        ctx.beginPath(); ctx.moveTo(cue.x,cue.y); ctx.lineTo(cue.x + Math.cos(ang)*len, cue.y + Math.sin(ang)*len);
        ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.stroke(); ctx.restore();
        return;
      }

      // heuristic ghost: for each object ball and pocket compute contact point; show ghost for best candidate
      let best=null;
      for(const obj of balls.filter(b=>b.id!==cueBallId && b.active)){
        for(const p of pockets){
          const px = p.x - obj.x, py = p.y - obj.y; const dPocket = Math.hypot(px,py);
          const contactX = obj.x - (px/dPocket)*ballRadius; const contactY = obj.y - (py/dPocket)*ballRadius;
          const dirX = contactX - cue.x, dirY = contactY - cue.y; const dCue = Math.hypot(dirX,dirY);
          const score = 1/(1 + dCue*0.008 + dPocket*0.01);
          if(!best || score > best.score) best = {obj,p,contact:{x:contactX,y:contactY},score,angle:Math.atan2(dirY,dirX)};
        }
      }
      if(best){
        ctx.save(); ctx.scale(canvas.getBoundingClientRect().width/760, canvas.getBoundingClientRect().width/760);
        // ghost ball
        ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.arc(best.contact.x,best.contact.y,ballRadius,0,Math.PI*2); ctx.fill();
        // path line
        ctx.beginPath(); ctx.moveTo(best.obj.x,best.obj.y); ctx.lineTo(best.p.x,best.p.y); ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=2; ctx.stroke();
        // line from cue to contact
        ctx.beginPath(); ctx.moveTo(balls.find(b=>b.id===cueBallId).x, balls.find(b=>b.id===cueBallId).y); ctx.lineTo(best.contact.x,best.contact.y); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.stroke();
        ctx.restore();
      }
    }

    function stepPhysics(){
      // move
      for(const b of balls){ if(!b.active) continue; b.x += b.vx; b.y += b.vy; b.vx *= friction; b.vy *= friction; if(Math.hypot(b.vx,b.vy) < 0.01){ b.vx=0; b.vy=0 }}

      // collisions
      for(let i=0;i<balls.length;i++){
        for(let j=i+1;j<balls.length;j++){
          const A = balls[i], B = balls[j]; if(!A.active || !B.active) continue;
          const dx = B.x - A.x, dy = B.y - A.y, dist = Math.hypot(dx,dy); const minD = A.r + B.r;
          if(dist < minD && dist>0){
            const nx = dx/dist, ny = dy/dist; const overlap = (minD - dist)/2; A.x -= nx*overlap; A.y -= ny*overlap; B.x += nx*overlap; B.y += ny*overlap;
            const relvx = B.vx - A.vx, relvy = B.vy - A.vy; const sep = relvx*nx + relvy*ny; if(sep < 0){ const impulse = -1.9 * sep; A.vx -= impulse*nx; A.vy -= impulse*ny; B.vx += impulse*nx; B.vy += impulse*ny; }
          }
        }
      }

      // rails
      for(const b of balls){ if(!b.active) continue; if(b.x < padding + b.r){ b.x = padding + b.r; b.vx *= -0.82 } if(b.x > W - padding - b.r){ b.x = W - padding - b.r; b.vx *= -0.82 } if(b.y < padding + b.r){ b.y = padding + b.r; b.vy *= -0.82 } if(b.y > H - padding - b.r){ b.y = H - padding - b.r; b.vy *= -0.82 } }

      // pockets
      for(const p of pockets){ for(const b of balls){ if(!b.active) continue; const d = Math.hypot(b.x-p.x,b.y-p.y); if(d < pocketRadius){ b.active = false; b.vx = 0; b.vy = 0; recordPot(b.id); } }}
    }

    function anyBallMoving(){ return balls.some(b=>b.active && (Math.abs(b.vx)>0.05 || Math.abs(b.vy)>0.05)); }

    function gameLoop(){
      stepPhysics(); drawTable(); // replay frame (store small snapshot)
      replay.push(balls.map(b=>({id:b.id,x:b.x,y:b.y,vx:b.vx,vy:b.vy,active:b.active})));
      if(!anyBallMoving()){
        if(currentTurn==='ai' && allowPlayerShot===false){ currentTurn='player'; allowPlayerShot=true; updateTurnLabel(); }
      }
      requestAnimationFrame(gameLoop);
    }

    function recordPot(ballId){
      if(ballId===cueBallId){ setTimeout(()=>{ const cue = balls.find(b=>b.id===cueBallId); if(cue){ cue.active=true; cue.x=160; cue.y=H/2; cue.vx=0; cue.vy=0 } },400); return; }
      if(currentTurn==='player' || allowPlayerShot===true){ const el = document.getElementById('playerScore'); const v = parseInt(el.textContent.split(':')[1]) + 1; el.textContent = 'Balls potted: ' + v; }
      else { const el = document.getElementById('aiScore'); const v = parseInt(el.textContent.split(':')[1]) + 1; el.textContent = 'Balls potted: ' + v; }
    }

    // input handling with improved precision
    let pointerDown = false;
    canvas.addEventListener('pointerdown', (e)=>{
      const rect = canvas.getBoundingClientRect(); const sx = e.clientX - rect.left, sy = e.clientY - rect.top; const w = screenToWorld(sx,sy);
      const cue = balls.find(b=>b.id===cueBallId && b.active);
      if(!cue) return;
      // if user touched near cue ball -> start drag for quick shot
      if(Math.hypot(w.x-cue.x,w.y-cue.y) < 40){ pointerDown=true; isAiming=true; aimStart={x:cue.x,y:cue.y}; aimEnd={x:w.x,y:w.y}; }
      else {
        // tap-to-aim: set queued aim from cue to tap
        const dx = w.x - cue.x, dy = w.y - cue.y; const ang = Math.atan2(dy,dx) * 180/Math.PI; queuedAim = { angle: ang, power: parseInt(powerInput.value) };
        setAngle(ang);
      }
    });
    canvas.addEventListener('pointermove', (e)=>{
      if(!isAiming) return; const rect = canvas.getBoundingClientRect(); const sx = e.clientX - rect.left, sy = e.clientY - rect.top; const w = screenToWorld(sx,sy); aimEnd.x = w.x; aimEnd.y = w.y; });
    canvas.addEventListener('pointerup', (e)=>{ if(isAiming){ isAiming=false; pointerDown=false; // compute shot from drag
      const cue = balls.find(b=>b.id===cueBallId && b.active); if(!cue) return; const dx = aimStart.x - aimEnd.x, dy = aimStart.y - aimEnd.y; const power = Math.min(55, Math.hypot(dx,dy)/3); const ang = Math.atan2(dy,dx); cue.vx = Math.cos(ang) * power * 0.6; cue.vy = Math.sin(ang) * power * 0.6; allowPlayerShot=false; currentTurn='player'; updateTurnLabel(); const waitForStop = setInterval(()=>{ if(!anyBallMoving()){ clearInterval(waitForStop); currentTurn='ai'; allowPlayerShot=false; updateTurnLabel(); setTimeout(()=>{ aiTakeTurn(); },700); } },400); } });

    // allow tap-to-aim + shoot via controls
    function performShootFromControls(){
      const cue = balls.find(b=>b.id===cueBallId && b.active); if(!cue) return; if(!queuedAim){ alert('Tap on the table to set where to aim first.'); return; }
      const ang = queuedAim.angle * Math.PI/180; const power = parseInt(powerInput.value);
      cue.vx = Math.cos(ang) * power * 0.6; cue.vy = Math.sin(ang) * power * 0.6; queuedAim = null; allowPlayerShot=false; currentTurn='player'; updateTurnLabel(); const waitForStop = setInterval(()=>{ if(!anyBallMoving()){ clearInterval(waitForStop); currentTurn='ai'; allowPlayerShot=false; updateTurnLabel(); setTimeout(()=>{ aiTakeTurn(); },700); } },400);
    }

    function updateTurnLabel(){ document.getElementById('turnLabel').textContent = currentTurn === 'player' ? 'Player' : 'System (AI)'; }

    // AI (keeps the same 50% fairness mechanism but uses improved aim/power values)
    function aiTakeTurn(){ const cue = balls.find(b=>b.id===cueBallId && b.active); if(!cue) return; const objects = balls.filter(b=>b.id
