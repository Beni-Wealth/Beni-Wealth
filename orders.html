<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>My Adverts — Beni-Wealth</title>

  <!-- Poppins -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300,400,600,700&display=swap" rel="stylesheet"/>

  <!-- Favicons & Social preview -->
  <link rel="icon" type="image/png" sizes="32x32" href="https://res.cloudinary.com/dq7fpxfbc/image/upload/v1752962852/file_00000000401861f8bf6acb6d55fcf2bf_g2fcrf.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://res.cloudinary.com/dq7fpxfbc/image/upload/v1752962852/file_00000000401861f8bf6acb6d55fcf2bf_g2fcrf.png">
  <meta name="msapplication-TileImage" content="https://res.cloudinary.com/dq7fpxfbc/image/upload/v1752962852/file_00000000401861f8bf6acb6d55fcf2bf_g2fcrf.png">

  <meta property="og:type" content="website">
  <meta property="og:title" content="Beni-Wealth — Earn Steadily">
  <meta property="og:description" content="Complete simple micro-tasks, complete shortlinks and earn instantly. Advertise efficiently with transparent metrics and fast payouts.">
  <meta property="og:image" content="https://res.cloudinary.com/dq7fpxfbc/image/upload/c_fill,w_1200,h_630/v1752962852/file_00000000401861f8bf6acb6d55fcf2bf_g2fcrf.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="theme-color" content="#2fe0b8">

  <style>
    :root{
      --bg1:#060511; --bg2:#0f0920;
      --muted: rgba(255,255,255,0.62);
      --text: #eaf2ff;
      --accent-start:#2fe0b8; --accent-end:#7a5fff;
      --card: rgba(255,255,255,0.02);
      --glass: rgba(255,255,255,0.03);
      --radius:12px;
      --max-width:1200px;
      --debug-bg: rgba(255,255,255,0.02);
    }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;font-family:'Poppins',sans-serif;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text);-webkit-font-smoothing:antialiased}
    .shell{max-width:var(--max-width);margin:20px auto;padding:20px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    .brand{font-weight:700;font-size:1.1rem}
    .back{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.03);text-decoration:none;color:var(--text)}
    .muted{color:var(--muted);font-size:13px}
    .toolbar{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    .search{flex:1;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
    .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;background:linear-gradient(90deg,var(--accent-start),var(--accent-end));color:#041219;font-weight:700}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:16px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 18px 60px rgba(0,0,0,0.55);display:flex;flex-direction:column;gap:12px}
    .card-head{display:flex;gap:12px;align-items:center;justify-content:space-between}
    .title{font-weight:700}
    .meta{color:var(--muted);font-size:13px}
    .thumb{width:96px;height:72px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
    .pill{padding:6px 10px;border-radius:999px;font-weight:700;font-size:12px}
    .pill.pending{background:#fff6d6;color:#6a4f00}
    .pill.approved{background:#bff0d9;color:#05461f}
    .pill.completed{background:#dbe9ff;color:#05304a}
    .card-body{color:var(--muted);font-size:14px;min-height:42px}
    .actions{display:flex;gap:8px;margin-top:6px}
    .details-collapse{overflow:hidden;max-height:0;transition:max-height .28s ease;padding-top:0}
    .details-inner{padding:12px;border-top:1px dashed rgba(255,255,255,0.04);display:flex;flex-direction:column;gap:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:0 0 10px 10px}
    .submission{display:flex;gap:12px;align-items:flex-start;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .sub-left{flex:1}
    .sub-thumb{max-width:100%;width:140px;height:auto;object-fit:contain;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:#000}
    .sub-meta{color:var(--muted);font-size:12px;margin-bottom:6px}
    .empty{padding:28px;text-align:center;color:var(--muted)}
    .diag{color:var(--muted);font-size:13px;margin-bottom:12px}
    .small{font-size:13px;color:var(--muted)}
    /* image overlay viewer */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:999;padding:18px}
    .viewer{width:100%;max-width:880px;background:#000;border-radius:12px;overflow:hidden;display:flex;flex-direction:column;align-items:center}
    .viewer img{max-width:100%;height:auto;display:block}
    .viewer .meta{padding:12px;background:rgba(0,0,0,0.5);color:var(--muted);width:100%;display:flex;justify-content:space-between}
    /* debug panel */
    .debug {
      margin-top:14px;padding:12px;border-radius:10px;background:var(--debug-bg);border:1px solid rgba(255,255,255,0.03);font-family:monospace;color:var(--muted);font-size:13px;line-height:1.45;white-space:pre-wrap;max-height:240px;overflow:auto;
    }
    @media(max-width:520px){ .thumb{width:78px;height:60px} .sub-thumb{width:100%;height:auto} }
  </style>
</head>
<body>
  <main class="shell">
    <header>
      <a class="back" href="dashboard.html">← Back</a>
      <div style="text-align:right">
        <div class="brand">My Adverts</div>
        <div class="muted">All adverts you created — track approvals and view submissions</div>
      </div>
    </header>

    <div class="toolbar">
      <input id="search" class="search" placeholder="Search by title, platform or status" />
      <button id="refresh" class="btn ghost">Refresh</button>
    </div>

    <div id="diag" class="diag">Connecting…</div>

    <div id="grid" class="grid" aria-live="polite">
      <div class="empty">Loading your adverts…</div>
    </div>

    <div id="debug" class="debug" aria-live="polite" role="status">
      Debug log — probe results and listener errors will appear here.
    </div>
  </main>

  <!-- Image viewer overlay -->
  <div id="viewerOverlay" class="overlay" aria-hidden="true">
    <div class="viewer" role="dialog" aria-modal="true">
      <img id="viewerImg" src="" alt="proof image" />
      <div class="meta">
        <div id="viewerMeta" class="small"></div>
        <div>
          <button id="viewerClose" class="btn ghost">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
    import {
      getFirestore, collection, query, where, onSnapshot, getDocs, doc,
      runTransaction, serverTimestamp
    } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';

    // FIREBASE CONFIG
    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // DOM
    const grid = document.getElementById('grid');
    const diag = document.getElementById('diag');
    const search = document.getElementById('search');
    const refreshBtn = document.getElementById('refresh');
    const debugEl = document.getElementById('debug');

    const viewerOverlay = document.getElementById('viewerOverlay');
    const viewerImg = document.getElementById('viewerImg');
    const viewerMeta = document.getElementById('viewerMeta');
    const viewerClose = document.getElementById('viewerClose');

    // state
    let currentUser = null;
    const advertsMap = new Map();
    const submissionsListeners = new Map();
    const advertsUnsubs = [];

    // short list of collection names to probe (keeps it small, extend if you use another)
    const CANDIDATE_COLLS = ['advertise_tasks', 'adverts', 'advert', 'advertise', 'advert_task', 'tasks'];
    const OWNER_FIELDS = ['createdBy','owner','userId','uid','requestedBy','creator','ownerUid','user'];

    // helpers
    function debug(msg){
      const time = new Date().toLocaleTimeString();
      debugEl.textContent = `[${time}] ${msg}\n` + debugEl.textContent;
    }
    function el(tag, attrs = {}, ...children){
      const e = document.createElement(tag);
      for(const k in attrs){
        if(k === 'class') e.className = attrs[k];
        else if(k === 'dataset') Object.assign(e.dataset, attrs[k]);
        else e.setAttribute(k, attrs[k]);
      }
      children.forEach(c => { if(typeof c === 'string') e.appendChild(document.createTextNode(c)); else if(c) e.appendChild(c); });
      return e;
    }
    function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    function niceDate(ts){ try{ if(!ts) return '-'; if(ts.toDate) ts = ts.toDate(); return new Date(ts).toLocaleString(); }catch(e){ return '-'; } }
    function statusClass(status){ const s = String(status||'').toLowerCase(); if(s==='pending') return 'pill pending'; if(s==='approved') return 'pill approved'; if(s==='completed') return 'pill completed'; return 'pill pending'; }

    // viewer
    function openImageViewer(url){
      viewerImg.src = url;
      viewerMeta.textContent = url;
      viewerOverlay.style.display = 'flex';
      viewerOverlay.setAttribute('aria-hidden','false');
      document.body.style.overflow = 'hidden';
    }
    function closeImageViewer(){
      viewerOverlay.style.display = 'none';
      viewerOverlay.setAttribute('aria-hidden','true');
      viewerImg.src = '';
      document.body.style.overflow = '';
    }
    viewerClose.addEventListener('click', closeImageViewer);
    viewerOverlay.addEventListener('click', (e)=> { if(e.target === viewerOverlay) closeImageViewer(); });

    // compute unit price defensively
    function getUnitPrice(adData){
      if(!adData) return 0;
      const candidates = ['unitPrice','unit_price','price','per','unit','amount'];
      for(const k of candidates){
        if(typeof adData[k] !== 'undefined' && adData[k] !== null && !isNaN(Number(adData[k]))) return Number(adData[k]);
      }
      const total = Number(adData.totalCost ?? adData.total_cost ?? adData.total ?? 0) || 0;
      const workers = Number(adData.workers ?? adData.worker_count ?? adData.requested_workers ?? 0) || 0;
      if(workers > 0 && total > 0) return total / workers;
      return 0;
    }

    // render grid + card builder (same as earlier)
    function rebuildGrid(){
      const q = (search.value || '').trim().toLowerCase();
      grid.innerHTML = '';
      let any = false;
      for(const [id, item] of advertsMap){
        const data = item.data || {};
        if(q){
          const hay = ((data.title||'') + ' ' + (data.platform||'') + ' ' + (data.subcategory||'') + ' ' + (data.status||'')).toLowerCase();
          if(!hay.includes(q)) continue;
        }
        const node = buildCard(id, data);
        grid.appendChild(node);
        any = true;
      }
      if(!any) grid.innerHTML = '<div class="empty">You have no adverts yet.</div>';
    }

    function buildCard(id, data){
      const head = el('div',{class:'card-head'});
      const left = el('div',{style:'display:flex;gap:12px;align-items:center'});
      const thumbSrc = data.thumbnail || data.thumb || data.image || '';
      const thumb = el('img',{class:'thumb', src: thumbSrc, alt: data.title || ''});
      if(!thumbSrc) thumb.style.display = 'none';
      thumb.addEventListener('click', ()=> { if(thumbSrc) openImageViewer(thumbSrc); });

      const txt = el('div', {},
        el('div',{class:'title'}, data.title || '(untitled)'),
        el('div',{class:'meta'}, `${escapeHtml(String(data.platform||data.subcategory||''))} • ${escapeHtml(String(data.workers||data.worker_count||data.requested_workers||0))} workers`)
      );
      left.appendChild(thumb);
      left.appendChild(txt);

      const right = el('div', {});
      const pill = el('div',{class: statusClass(data.status)}, (data.status||'PENDING').toString().toUpperCase());
      right.appendChild(pill);

      head.appendChild(left);
      head.appendChild(right);

      const body = el('div',{class:'card-body'}, data.description ? (data.description.slice(0,220) + (data.description.length>220? '…':'')) : el('span',{},'No description'));

      const actions = el('div',{class:'actions'});
      const detailsBtn = el('button',{class:'btn ghost'}, 'Details');
      actions.appendChild(detailsBtn);

      const collapseInner = el('div',{class:'details-inner'}, el('div',{class:'small muted'}, 'Loading submissions…'));
      const collapse = el('div',{class:'details-collapse', id:`collapse-${id}`}, collapseInner);

      let expanded = false;
      detailsBtn.addEventListener('click', async () => {
        expanded = !expanded;
        if(expanded){
          await attachSubmissionsListener(id, collapseInner);
          requestAnimationFrame(()=> {
            const sh = collapseInner.scrollHeight;
            collapse.style.maxHeight = (sh + 24) + 'px';
          });
        } else {
          collapse.style.maxHeight = '0';
          detachSubmissionsListener(id);
        }
      });

      const card = el('article',{class:'card', dataset:{id}}, head, body, actions, collapse);
      return card;
    }

    // attach submissions listener
    function attachSubmissionsListener(advertId, containerEl){
      if(submissionsListeners.has(advertId)) return;
      containerEl.innerHTML = '<div class="small muted">Loading submissions…</div>';

      const subCol = 'advert_submissions';
      const q = query(collection(db, subCol), where('advertId','==', advertId));

      const unsub = onSnapshot(q, (snap) => {
        const list = [];
        snap.forEach(s => {
          const d = s.data() || {};
          list.push({
            id: s.id,
            userId: d.userId || d.user || d.requestedBy || d.workerId || '',
            textProof: d.textProof || d.text_proof || d.proofText || '',
            imageUrl: d.imageUrl || d.image_url || d.image || '',
            status: d.status || 'pending',
            createdAt: d.createdAt || d.created_at || null,
            paidAmount: d.paidAmount || d.paid_amount || d.paid || null
          });
        });

        list.sort((a,b)=>{
          const ta = a.createdAt && a.createdAt.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?Date.parse(a.createdAt):0);
          const tb = b.createdAt && b.createdAt.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?Date.parse(b.createdAt):0);
          return tb - ta;
        });

        if(list.length === 0) {
          containerEl.innerHTML = '<div class="empty small muted">No submissions yet.</div>';
          return;
        }

        containerEl.innerHTML = '';
        for(const s of list){
          const sub = el('div',{class:'submission'});
          const left = el('div',{class:'sub-left'},
            el('div',{class:'sub-meta'}, `Submitted: ${niceDate(s.createdAt)} • ID: ${s.id} • By: ${escapeHtml(s.userId||'-')}`),
            el('div',{}, s.textProof || el('em',{}, '(no text proof)'))
          );

          const right = el('div',{style:'min-width:160px;text-align:right;display:flex;flex-direction:column;align-items:flex-end;gap:8px'});

          if(s.imageUrl){
            const img = el('img',{class:'sub-thumb', src:s.imageUrl, alt:'proof'});
            img.addEventListener('click', ()=> openImageViewer(s.imageUrl));
            right.appendChild(img);
          }

          const stLower = (s.status||'').toLowerCase();
          const statusBadge = el('div',{class:`pill ${stLower==='approved' ? 'approved' : stLower==='completed' ? 'completed' : 'pending' }`}, (s.status||'PENDING').toString().toUpperCase());
          right.appendChild(statusBadge);

          // owner controls (only visible to owner)
          const advert = advertsMap.get(advertId);
          const advertOwnerId = advert?.data ? (advert.data.createdBy || advert.data.owner || advert.data.userId || advert.data.uid || advert.data.requestedBy || advert.data.creator || advert.data.ownerUid || advert.data.user || null) : null;
          const unitPrice = getUnitPrice(advert?.data || {});
          const payAmount = Math.round(unitPrice * 0.7);

          if(currentUser && advertOwnerId && currentUser.uid === advertOwnerId){
            // approval controls — same logic as before, with enforcement
            const controls = el('div',{style:'display:flex;gap:6px;flex-direction:row;'});
            const approveBtn = el('button',{class:'btn'}, '');
            const rejectBtn = el('button',{class:'btn ghost'}, '');

            if(stLower === 'approved'){
              approveBtn.textContent = `Unapprove`;
              rejectBtn.textContent = `Reject`;
              rejectBtn.disabled = true;
              rejectBtn.title = 'Cannot reject an already-approved submission';
            } else if(stLower === 'rejected'){
              approveBtn.textContent = `Approve (₦${payAmount.toLocaleString()})`;
              rejectBtn.textContent = `Unreject`;
            } else {
              approveBtn.textContent = `Approve (₦${payAmount.toLocaleString()})`;
              rejectBtn.textContent = `Reject`;
            }

            approveBtn.addEventListener('click', async ()=>{
              approveBtn.disabled = true;
              try {
                if(stLower === 'approved'){
                  await setSubmissionStatusWithPaymentAdjustment(s.id, 'pending');
                } else {
                  await setSubmissionStatusWithPaymentAdjustment(s.id, 'approved');
                }
              } catch(e){
                console.error(e);
                alert('Action failed: ' + (e.message || e));
              } finally { approveBtn.disabled = false; }
            });

            rejectBtn.addEventListener('click', async ()=>{
              if(rejectBtn.disabled) return;
              rejectBtn.disabled = true;
              try {
                if(stLower === 'rejected'){
                  await setSubmissionStatusWithPaymentAdjustment(s.id, 'pending');
                } else {
                  await setSubmissionStatusWithPaymentAdjustment(s.id, 'rejected');
                }
              } catch(e){
                console.error(e);
                alert('Action failed: ' + (e.message || e));
              } finally { rejectBtn.disabled = false; }
            });

            controls.appendChild(approveBtn);
            controls.appendChild(rejectBtn);
            right.appendChild(controls);
          }

          sub.appendChild(left);
          sub.appendChild(right);
          containerEl.appendChild(sub);
        }
      }, err => {
        console.error('submissions listen error', err);
        debug(`submissions listen error for advert ${advertId}: ${err.message || err}`);
        containerEl.innerHTML = `<div class="empty">Failed to load submissions: ${escapeHtml(err.message || String(err))}</div>`;
      });

      submissionsListeners.set(advertId, unsub);
    }

    function detachSubmissionsListener(advertId){
      const unsub = submissionsListeners.get(advertId);
      if(unsub){ try{ unsub(); }catch(e){} }
      submissionsListeners.delete(advertId);
    }
    function detachAllSubmissionListeners(){
      for(const [k, unsub] of submissionsListeners.entries()){
        try{ unsub(); }catch(e){}
      }
      submissionsListeners.clear();
    }

    // setSubmissionStatusWithPaymentAdjustment is same as before (keeps enforcement)
    async function setSubmissionStatusWithPaymentAdjustment(submissionId, targetStatus){
      if(!submissionId) throw new Error('Invalid submission id');
      const submissionRef = doc(db, 'advert_submissions', submissionId);

      await runTransaction(db, async (tx) => {
        const subSnap = await tx.get(submissionRef);
        if(!subSnap.exists()) throw new Error('Submission not found');
        const sub = subSnap.data() || {};
        const curStatus = (sub.status || 'pending').toLowerCase();
        const target = (targetStatus || '').toLowerCase();
        if(curStatus === target) return;

        if(curStatus === 'approved' && target === 'rejected'){
          throw new Error('Operation not allowed: an approved submission cannot be changed to rejected.');
        }

        const submitterUid = sub.userId || sub.user || sub.requestedBy || sub.workerId || null;
        const paidAmountExisting = Number(sub.paidAmount ?? sub.paid_amount ?? sub.paid || 0);

        const advertId = sub.advertId || sub.advertID || sub.taskId || sub.task_id || null;
        let unitPrice = 0;
        if(advertId){
          try {
            const advertRef = doc(db, 'advertise_tasks', advertId);
            const advSnap = await tx.get(advertRef);
            if(advSnap.exists()){
              const adv = advSnap.data() || {};
              unitPrice = getUnitPrice(adv);
            }
          } catch(e){ /* ignore */ }
        }
        const payAmount = Math.round((unitPrice || 0) * 0.7);

        if(target === 'approved'){
          if(curStatus !== 'approved'){
            if(!submitterUid) throw new Error('Submission missing submitter id');
            const userRef = doc(db, 'users', submitterUid);
            const userSnap = await tx.get(userRef);
            if(userSnap.exists()){
              const u = userSnap.data() || {};
              const balanceFields = ['balance','wallet','funds','walletBalance'];
              let chosen = null;
              let currentBalance = 0;
              for(const f of balanceFields){ if(typeof u[f] !== 'undefined' && u[f] !== null && !isNaN(Number(u[f]))){ chosen = f; currentBalance = Number(u[f]); break; } }
              if(chosen){
                const newBal = Number(currentBalance || 0) + Number(payAmount || 0);
                const upd = {}; upd[chosen] = newBal;
                tx.update(userRef, upd);
              } else {
                tx.update(userRef, { balance: Number(u.balance || 0) + Number(payAmount || 0) });
              }
            } else {
              tx.set(doc(db,'users',submitterUid), { balance: Number(payAmount || 0) }, { merge: true });
            }
            tx.update(submissionRef, {
              status: 'approved',
              approvedAt: serverTimestamp(),
              paidAmount: Number(payAmount || 0),
              paidBy: currentUser ? currentUser.uid : null
            });
          }
        } else if(target === 'rejected'){
          tx.update(submissionRef, { status: 'rejected', rejectedAt: serverTimestamp() });
        } else if(target === 'pending'){
          if(curStatus === 'approved' && paidAmountExisting > 0){
            if(!submitterUid) throw new Error('Submission missing submitter id');
            const userRef = doc(db, 'users', submitterUid);
            const userSnap = await tx.get(userRef);
            if(userSnap.exists()){
              const u = userSnap.data() || {};
              const balanceFields = ['balance','wallet','funds','walletBalance'];
              let chosen = null;
              let currentBalance = 0;
              for(const f of balanceFields){ if(typeof u[f] !== 'undefined' && u[f] !== null && !isNaN(Number(u[f]))){ chosen = f; currentBalance = Number(u[f]); break; } }
              if(chosen){
                const newBal = Math.max(0, Number(currentBalance || 0) - Number(paidAmountExisting || 0));
                const upd = {}; upd[chosen] = newBal;
                tx.update(userRef, upd);
              } else {
                tx.update(userRef, { balance: Math.max(0, Number(u.balance || 0) - Number(paidAmountExisting || 0)) });
              }
            }
            tx.update(submissionRef, { status: 'pending', updatedAt: serverTimestamp(), refunded: true });
          } else {
            tx.update(submissionRef, { status: 'pending', updatedAt: serverTimestamp() });
          }
        }
      });
    }

    // PROBE collections for the user's adverts. returns chosen collection name and ownerField used
    async function probeCollectionsForUser(uid){
      debug(`Starting probe for user ${uid}...`);
      for(const coll of CANDIDATE_COLLS){
        try{
          const colRef = collection(db, coll);
          // try a small quick get (no where) to inspect fields if read allowed (catches permission errors quickly)
          const snap = await getDocs(colRef);
          if(!snap.empty){
            debug(`Collection "${coll}" reachable — docs: ${snap.size}. Sample doc IDs: ${snap.docs.slice(0,3).map(d=>d.id).join(', ')}`);
            // inspect first doc for a likely owner field
            const sample = snap.docs[0].data() || {};
            for(const f of OWNER_FIELDS){
              if(typeof sample[f] !== 'undefined'){
                // attempt a targeted query: where(f, '==', uid)
                try{
                  const q = query(collection(db, coll), where(f, '==', uid));
                  const res = await getDocs(q);
                  if(!res.empty){
                    debug(`Found adverts in "${coll}" where ${f} == ${uid} — ${res.size} matching docs.`);
                    return { collection: coll, ownerField: f };
                  } else {
                    debug(`No documents in "${coll}" matched ${f} == ${uid} (0 results).`);
                  }
                }catch(err){
                  debug(`Query error in "${coll}" using field ${f}: ${err.message || err}`);
                }
              }
            }
            // no owner-field match on first doc — still record sample info for debugging
            debug(`Inspected "${coll}" sample doc fields: ${Object.keys(sample).slice(0,12).join(', ')}`);
          } else {
            debug(`Collection "${coll}" reachable but empty.`);
          }
        }catch(err){
          debug(`Cannot read "${coll}": ${err.message || err}`);
        }
      }
      debug('Probe finished — no direct owner-field match found.');
      return null;
    }

    // Start adverts listeners using the best collection/field found
    async function startAdvertsListeners(uid){
      advertsMap.clear();
      // teardown previous
      for(const u of advertsUnsubs){ try{ u(); } catch(e){} }
      advertsUnsubs.length = 0;
      detachAllSubmissionListeners();

      grid.innerHTML = '<div class="empty">Loading your adverts…</div>';
      diag.textContent = 'Probing collections...';
      debug(`--- probe start for user ${uid} ---`);

      const probe = await probeCollectionsForUser(uid);
      if(probe && probe.collection){
        const coll = probe.collection;
        const field = probe.ownerField;
        diag.textContent = `Listening for adverts in "${coll}" where ${field} == you`;
        debug(`Attaching realtime listener on collection "${coll}" using owner field "${field}"`);
        try{
          const q = query(collection(db, coll), where(field, '==', uid));
          const unsub = onSnapshot(q, snap => {
            snap.forEach(docSnap => {
              advertsMap.set(docSnap.id, { id: docSnap.id, data: docSnap.data() });
            });
            rebuildGrid();
            diag.textContent = `Found ${advertsMap.size} adverts`;
            debug(`Realtime snapshot from "${coll}" (${snap.size} docs).`);
          }, err => {
            debug(`Realtime listener error for "${coll}": ${err.message || err}`);
            diag.textContent = `Listener error: ${err.message || err}`;
          });
          advertsUnsubs.push(unsub);
          // also attach a broad listener in background for statuses (optional)
          try{
            const qAll = query(collection(db, coll));
            const unsubAll = onSnapshot(qAll, snapAll => {
              snapAll.forEach(docSnap => {
                const d = docSnap.data() || {};
                // if doc likely belongs to this user, keep it
                const ownerVal = d[field];
                if(ownerVal === uid || (Array.isArray(ownerVal) && ownerVal.includes && ownerVal.includes(uid))){
                  advertsMap.set(docSnap.id, { id: docSnap.id, data: d });
                }
              });
              rebuildGrid();
            }, err => debug(`broad listener error for "${coll}": ${err.message || err}`));
            advertsUnsubs.push(unsubAll);
          }catch(e){ debug('Could not attach broad listener: ' + e.message); }

          // done
          return;
        }catch(e){
          debug(`Failed to attach realtime listener on "${coll}": ${e.message || e}`);
        }
      }

      // If we get here, probe failed to find a query match or realtime attach failed — fall back to a one-time scan of 'advertise_tasks'
      diag.textContent = 'No tailored collection found — falling back to a one-time scan.';
      debug('Falling back to one-time scan of advertise_tasks (best-effort).');
      try{
        const fallbackSnap = await getDocs(collection(db, 'advertise_tasks'));
        if(!fallbackSnap.empty){
          fallbackSnap.forEach(docSnap => {
            const d = docSnap.data() || {};
            // keep docs that appear to belong to the user by checking owner-like fields
            const possible = OWNER_FIELDS.some(f => {
              const v = d[f];
              return v === uid || (Array.isArray(v) && v.includes && v.includes(uid));
            });
            if(possible) advertsMap.set(docSnap.id, { id: docSnap.id, data: d });
          });
          if(advertsMap.size > 0){
            diag.textContent = `Found ${advertsMap.size} adverts (fallback).`;
            rebuildGrid();
            debug('Fallback one-time scan populated advertsMap.');
            return;
          } else {
            diag.textContent = 'No adverts found in fallback scan (or insufficient read permission).';
            debug('Fallback scan returned no adverts belonging to user.');
            grid.innerHTML = '<div class="empty">No adverts found for your account (or insufficient permissions).</div>';
            return;
          }
        } else {
          diag.textContent = 'Fallback collection empty or not readable.';
          debug('Fallback getDocs returned empty snapshot for advertise_tasks.');
          grid.innerHTML = '<div class="empty">No adverts found (fallback empty).</div>';
        }
      }catch(e){
        debug('Fallback scan failed: ' + (e.message || e));
        diag.textContent = 'Failed to read adverts (check Firestore rules).';
        grid.innerHTML = '<div class="empty">Failed to load adverts (see debug log).</div>';
      }
    }

    // teardown helpers
    function stopAllAdvertsListeners(){
      for(const u of advertsUnsubs){ try{ u(); } catch(e){} }
      advertsUnsubs.length = 0;
    }

    // auth
    onAuthStateChanged(auth, user => {
      currentUser = user;
      if(!user){
        diag.textContent = 'Please sign in to view your adverts.';
        grid.innerHTML = '<div class="empty">Sign in to see your adverts.</div>';
        debug('User not signed in.');
        return;
      }
      diag.textContent = `Signed in as ${user.email || user.displayName || user.uid.slice(0,8)}`;
      debug(`Authenticated as ${user.uid} (${user.email || 'no-email'})`);
      startAdvertsListeners(user.uid).catch(e => debug('startAdvertsListeners error: ' + (e.message || e)));
    });

    // UI events
    search.addEventListener('input', () => rebuildGrid());
    refreshBtn.addEventListener('click', () => {
      if(!currentUser) return;
      stopAllAdvertsListeners();
      advertsMap.clear();
      detachAllSubmissionListeners();
      startAdvertsListeners(currentUser.uid);
    });

    window.addEventListener('beforeunload', () => {
      stopAllAdvertsListeners();
      detachAllSubmissionListeners();
    });
  </script>
</body>
</html>
