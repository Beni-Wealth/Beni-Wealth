<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth â€” Snakes & Ladder</title>
  <meta name="theme-color" content="#2fe0b8" />
  <style>
    :root{
      --bg:#041225;
      --card:#0b1220;
      --accent:#7a5fff;
      --accent-2:#35d6b1;
      --muted:rgba(255,255,255,0.72);
      --muted-2:rgba(255,255,255,0.45);
      --win:#10b981;
      --lose:#ef4444;
      font-family:Inter, Poppins, system-ui, Arial;
      color:#eaf2ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#031022);display:flex;align-items:center;justify-content:center;padding:18px}
    .app{width:100%;max-width:1100px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:18px;display:grid;grid-template-columns:1fr 360px;gap:14px;box-shadow:0 30px 80px rgba(2,6,23,0.75)}
    @media(max-width:920px){ .app{grid-template-columns:1fr;max-width:420px;padding:12px} }
    .board-wrap{padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    .controls{padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:12px}
    .grid{width:100%;aspect-ratio:1/1;display:grid;grid-template-columns:repeat(10,1fr);gap:6px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:8px;border-radius:10px}
    .cell{border-radius:8px;display:block;padding:8px;font-size:12px;color:var(--muted);position:relative;overflow:visible;min-height:0; user-select:none}
    .cell .num{position:absolute;left:8px;top:6px;font-weight:800;color:var(--muted-2);font-size:12px;z-index:2}
    .cell .feature{position:absolute;right:8px;top:6px;font-size:18px;opacity:0.95;z-index:2}
    .cell.ladder-start{box-shadow:0 6px 18px rgba(16,185,129,0.06) inset;border:1px solid rgba(16,185,129,0.06)}
    .cell.snake-start{box-shadow:0 6px 18px rgba(239,68,68,0.04) inset;border:1px solid rgba(239,68,68,0.05)}
    .cell.hl{animation: pulse 700ms ease 0s 2; } @keyframes pulse { 0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)} }

    .token{position:absolute;width:44px;height:44px;border-radius:50%;display:grid;place-items:center;font-weight:900;color:#041219;z-index:60;transition:transform 320ms cubic-bezier(.2,.9,.2,1), box-shadow 320ms}
    .token.player{background:linear-gradient(90deg,var(--accent),var(--accent-2)); box-shadow:0 12px 40px rgba(122,95,255,0.18)}
    .token.bot{background:linear-gradient(90deg,#ffb86b,#ff7a7a); box-shadow:0 12px 40px rgba(255,120,110,0.18)}
    .dice{width:92px;height:92px;border-radius:12px;display:grid;place-items:center;font-weight:900;font-size:36px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);text-align:center;box-shadow:0 8px 32px rgba(2,6,23,0.6)}
    .dice.rolling{animation: dice-spin 900ms linear infinite}
    @keyframes dice-spin { from{ transform: rotate(0deg) } to{ transform: rotate(360deg) } }
    .roll-anim { transform: translateY(-8px) scale(1.06); transition: transform 220ms cubic-bezier(.2,.9,.2,1); }

    .btn{padding:10px 14px;border-radius:12px;border:0;background:linear-gradient(90deg,var(--accent),#5b3bff);color:#041219;font-weight:800;cursor:pointer;box-shadow:0 10px 30px rgba(90,50,180,0.12)}
    .btn-ghost{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted)}
    .muted{color:var(--muted);font-size:13px}
    .history{height:160px;overflow:auto;border-radius:10px;padding:10px;background:rgba(255,255,255,0.01);font-size:13px}
    .status{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);font-weight:800}
    .small{font-size:13px;color:var(--muted)}
    .footer{display:flex;gap:8px;align-items:center;justify-content:space-between}

    /* confetti */
    .confetti-wrapper { pointer-events:none; position:fixed; inset:0; z-index:9999; overflow:hidden; }
    .confetti { position:absolute; width:10px; height:16px; opacity:0.95; transform-origin:center; border-radius:2px; animation: fall linear forwards; }
    @keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity:1; } 100% { transform: translateY(110vh) rotate(720deg); opacity:0.95; } }

    .slide-anim { transition: transform 700ms cubic-bezier(.2,.9,.2,1); transform-origin:center; filter:drop-shadow(0 18px 40px rgba(2,6,23,0.7)); }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Snakes and ladders">
    <div class="board-wrap" aria-live="polite">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <div style="font-weight:900">Snakes & Ladders â€¢ Beni-Wealth</div>
        <div class="small">Player vs Bot â€” fair, visual and dramatic. Entry fee: â‚¦50 (charged at start).</div>
      </div>

      <div id="board" class="grid" aria-label="game board"></div>

      <!-- tokens -->
      <div id="playerToken" class="token player" aria-hidden="true">P</div>
      <div id="botToken" class="token bot" aria-hidden="true">B</div>

    </div>

    <div class="controls">
      <div class="status" id="status">Welcome â€” press <strong>Start</strong> to play</div>

      <div style="display:flex;gap:12px;align-items:center">
        <div id="dice" class="dice" aria-live="polite" aria-atomic="true">â€”</div>

        <div style="display:flex;flex-direction:column;gap:8px">
          <button id="rollBtn" class="btn" aria-label="Roll dice">Roll</button>
          <button id="startBtn" class="btn-ghost" aria-label="Start new game">Start New Game</button>
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <div class="small">Rule</div>
        <div style="margin-left:6px" class="muted small">Ladder: +15 â€” Snake: -10. Overshoot (need exact): turn skipped.</div>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <label class="small">Sound</label><input type="checkbox" id="soundToggle" checked />
        </div>
      </div>

      <div style="margin-top:8px">
        <div style="font-weight:800">Game log</div>
        <div id="log" class="history" aria-live="polite"></div>
      </div>

      <div class="footer" style="margin-top:8px">
        <div class="small">Made for Beni-Wealth</div>
        <div>
          <button id="saveBtn" class="btn-ghost">Save result</button>
        </div>
      </div>
    </div>
  </div>

  <div id="confettiRoot" class="confetti-wrapper" style="display:none"></div>

  <script type="module">
    // Firebase (modular)
    import { initializeApp, getApps, getApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
    import {
      getFirestore, collection, addDoc, serverTimestamp,
      doc, runTransaction, setDoc
    } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';

    // Firebase config (your project)
    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };
    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // UI refs
    const boardEl = document.getElementById('board');
    const playerToken = document.getElementById('playerToken');
    const botToken = document.getElementById('botToken');
    const rollBtn = document.getElementById('rollBtn');
    const startBtn = document.getElementById('startBtn');
    const diceEl = document.getElementById('dice');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const saveBtn = document.getElementById('saveBtn');
    const confettiRoot = document.getElementById('confettiRoot');
    const soundToggle = document.getElementById('soundToggle');

    // config
    const SIZE = 10;
    const CELL_COUNT = SIZE * SIZE;
    const ENTRY_FEE = 50;
    const REWARD = 70;

    // defines
    const ladderStarts = new Set([4,9,20,28,40,51,63,71]);
    const snakeStarts = new Set([98,95,92,87,64,62,54,17]);

    // state
    let currentUser = null;
    let playerPos = 1, botPos = 1;
    let playerTurn = true;
    let running = false;
    let isRolling = false;
    let feeTaken = false;
    let currentSessionId = null; // id of session doc in snakesSessions

    // build board visually
    function buildBoard(){
      boardEl.innerHTML = '';
      for(let num = 1; num <= CELL_COUNT; num++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.num = num;
        const rowFromBottom = Math.floor((num-1)/SIZE);
        const shade = ((rowFromBottom + (num % 2)) % 2 === 0) ? 'rgba(255,255,255,0.018)' : 'rgba(255,255,255,0.01)';
        cell.style.background = `linear-gradient(180deg, ${shade}, transparent)`;
        const n = document.createElement('div'); n.className = 'num'; n.textContent = num;
        cell.appendChild(n);
        if(ladderStarts.has(num)){
          const f = document.createElement('div'); f.className = 'feature'; f.textContent = 'ðŸªœ';
          cell.classList.add('ladder-start'); cell.appendChild(f);
        } else if(snakeStarts.has(num)){
          const f = document.createElement('div'); f.className = 'feature'; f.textContent = 'ðŸ';
          cell.classList.add('snake-start'); cell.appendChild(f);
        }
        boardEl.appendChild(cell);
      }
    }

    function getDisplayIndexForNumber(n){
      const rowFromBottom = Math.floor((n-1)/SIZE);
      const leftToRight = (rowFromBottom % 2 === 0);
      const col = leftToRight ? ((n-1) % SIZE) : (SIZE - 1 - ((n-1) % SIZE));
      const displayRow = SIZE - 1 - rowFromBottom;
      return displayRow * SIZE + col;
    }
    function getCellElementByNumber(n){
      const idx = getDisplayIndexForNumber(n);
      return boardEl.children[idx];
    }

    function placeTokens(){
      const pCell = getCellElementByNumber(playerPos);
      const bCell = getCellElementByNumber(botPos);
      if(pCell) pCell.appendChild(playerToken);
      if(bCell) bCell.appendChild(botToken);
      playerToken.style.transform = 'translate(0,0)';
      botToken.style.transform = 'translate(0,0)';
    }

    // audio helper
    function playBeep(freq=440, dur=110){
      try{
        if(!soundToggle.checked) return;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine'; o.frequency.value = freq;
        o.connect(g); g.connect(ctx.destination);
        g.gain.value = 0.0001;
        o.start();
        g.gain.exponentialRampToValueAtTime(0.12, ctx.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + (dur/1000));
        setTimeout(()=>{ try{ o.stop(); ctx.close(); }catch(_){} }, dur+50);
      }catch(e){}
    }

    // dramatic roll
    async function dramaticRoll(){
      if(isRolling) return null;
      isRolling = true;
      diceEl.classList.add('rolling','roll-anim');
      const duration = 700 + Math.floor(Math.random()*600);
      let final = 1;
      return new Promise(resolve => {
        const i = setInterval(()=>{
          const r = Math.floor(Math.random()*6)+1;
          diceEl.textContent = r;
          playBeep(320 + r*50, 36);
          final = r;
        }, 60);
        setTimeout(()=>{
          clearInterval(i);
          final = Math.floor(Math.random()*6)+1;
          diceEl.textContent = final;
          playBeep(760 + final*40, 220);
          diceEl.classList.remove('rolling');
          setTimeout(()=> diceEl.classList.remove('roll-anim'), 240);
          isRolling = false;
          resolve(final);
        }, duration);
      });
    }

    async function animateTokenStepwise(token, from, to){
      if(from === to) return;
      const step = (to > from) ? 1 : -1;
      for(let p = from + step; (step > 0 ? p <= to : p >= to); p += step){
        const cell = getCellElementByNumber(p);
        cell.classList.add('hl');
        cell.appendChild(token);
        token.style.transform = (step>0) ? 'translateY(-6px)' : 'translateY(6px)';
        await wait(120);
        token.style.transform = 'translateY(0)';
        cell.classList.remove('hl');
        await wait(80);
      }
    }

    async function animateSlide(token, from, to){
      const fromCell = getCellElementByNumber(from);
      const toCell = getCellElementByNumber(to);
      fromCell.classList.add('hl'); toCell.classList.add('hl');
      const clone = token.cloneNode(true);
      clone.classList.add('slide-anim');
      document.body.appendChild(clone);
      const rectFrom = fromCell.getBoundingClientRect();
      const rectTo = toCell.getBoundingClientRect();
      clone.style.position = 'fixed';
      clone.style.left = (rectFrom.left + rectFrom.width/2 - clone.offsetWidth/2) + 'px';
      clone.style.top = (rectFrom.top + rectFrom.height/2 - clone.offsetHeight/2) + 'px';
      await wait(40);
      clone.style.transform = `translate(${rectTo.left - rectFrom.left}px, ${rectTo.top - rectFrom.top}px) scale(1.06)`;
      playBeep(560, 220);
      await wait(700);
      clone.remove();
      try{ toCell.appendChild(token); }catch(e){}
      fromCell.classList.remove('hl'); toCell.classList.remove('hl');
    }

    function wait(ms){ return new Promise(r => setTimeout(r, ms)); }
    function logMsg(msg){ const d=document.createElement('div'); d.textContent = `${(new Date()).toLocaleTimeString()} â€” ${msg}`; logEl.prepend(d); if(logEl.children.length>200) logEl.removeChild(logEl.lastChild); }
    function setStatus(t){ statusEl.textContent = t; }

    function applyFeature(pos){
      if(ladderStarts.has(pos)){
        const next = Math.min(CELL_COUNT, pos + 15);
        return { next, type: 'ladder' };
      }
      if(snakeStarts.has(pos)){
        const next = Math.max(1, pos - 10);
        return { next, type: 'snake' };
      }
      return { next: pos, type: null };
    }
    function wouldOvershoot(pos, roll){ return (pos + roll) > CELL_COUNT; }

    // --- Billing: charge entry fee before starting ---
    async function chargeEntryFee(){
      if(!currentUser) { alert('Please sign in before playing.'); throw new Error('not-signed-in'); }
      const uid = currentUser.uid;
      const userRef = doc(db, 'users', uid);
      const balancesRef = doc(db, 'balances', uid);
      try {
        // transaction: read both docs, decide balance, write new balance and create session doc
        const sessionId = await runTransaction(db, async (tx) => {
          const [uSnap, bSnap] = await Promise.all([tx.get(userRef), tx.get(balancesRef)]);
          let bal = null;
          if(uSnap.exists()){
            const ud = uSnap.data() || {};
            bal = (typeof ud.balance === 'number') ? ud.balance : (typeof ud.amount === 'number' ? ud.amount : null);
          }
          if((bal === null || bal === undefined) && bSnap.exists()){
            const bd = bSnap.data() || {};
            bal = (typeof bd.balance === 'number') ? bd.balance : (typeof bd.amount === 'number' ? bd.amount : null);
          }
          if(bal === null || bal === undefined) bal = 0;
          if(bal < ENTRY_FEE) throw new Error('insufficient-funds');
          const newBal = Number(bal) - ENTRY_FEE;
          tx.set(userRef, { balance: newBal }, { merge: true });
          // create session doc
          const sessionRef = doc(collection(db, 'snakesSessions'));
          tx.set(sessionRef, {
            userId: uid,
            startedAt: serverTimestamp(),
            feeCharged: ENTRY_FEE,
            credited: false,
            status: 'started'
          });
          // return session id so client can reference it
          return sessionRef.id;
        });
        // success
        feeTaken = true;
        currentSessionId = sessionId;
        // discreet confirmation to user
        setStatus(`â‚¦${ENTRY_FEE.toLocaleString()} debited â€” game started.`);
        logMsg(`Entry fee â‚¦${ENTRY_FEE} debited (session ${sessionId})`);
        return true;
      } catch (err) {
        if(err && err.message === 'insufficient-funds'){
          alert('Insufficient balance to join the game. Please top up.');
        } else {
          console.warn('chargeEntryFee failed', err);
          alert('Could not charge entry fee: ' + (err.message || err));
        }
        throw err;
      }
    }

    // credit reward to user when they win
    async function creditReward(){
      if(!currentUser) return;
      const uid = currentUser.uid;
      const userRef = doc(db, 'users', uid);
      let sessionRef = null;
      if(currentSessionId) sessionRef = doc(db, 'snakesSessions', currentSessionId);

      try {
        await runTransaction(db, async (tx) => {
          // optionally verify session hasn't already been credited
          if(sessionRef){
            const sSnap = await tx.get(sessionRef);
            if(sSnap.exists()){
              const sdata = sSnap.data() || {};
              if(sdata.credited) {
                // already credited
                return;
              }
            }
          }
          // read user doc and balances doc to compute existing balance
          const uSnap = await tx.get(userRef);
          let bal = null;
          if(uSnap.exists()){
            const ud = uSnap.data() || {};
            bal = (typeof ud.balance === 'number') ? ud.balance : (typeof ud.amount === 'number' ? ud.amount : null);
          }
          if(bal === null || bal === undefined) bal = 0;
          const newBal = Number(bal) + REWARD;
          tx.set(userRef, { balance: newBal }, { merge: true });
          // update session doc to mark credited
          if(sessionRef){
            tx.set(sessionRef, { credited: true, creditedAt: serverTimestamp(), reward: REWARD, status: 'completed' }, { merge: true });
          } else {
            // best-effort: create a session doc if missing
            const sessionRefAuto = doc(collection(db, 'snakesSessions'));
            tx.set(sessionRefAuto, { userId: uid, startedAt: serverTimestamp(), feeCharged: feeTaken ? ENTRY_FEE : 0, credited: true, creditedAt: serverTimestamp(), reward: REWARD, status:'completed', note:'auto-created' });
            currentSessionId = sessionRefAuto.id;
          }
        });
        // notify user discreetly
        setStatus(`You won â€” â‚¦${REWARD.toLocaleString()} credited.`);
        logMsg(`Reward â‚¦${REWARD} credited (session ${currentSessionId})`);
      } catch(e){
        console.warn('creditReward failed', e);
        // still show win message but mention credit couldn't be completed
        setStatus('You won! Reward pending (could not credit automatically).');
        logMsg('Reward credit failed â€” admin will reconcile.');
      }
    }

    // Bot move
    async function botMove(){
      if(!running) return;
      setStatus('Bot thinking...');
      await wait(550 + Math.random()*600);
      let roll = await dramaticRoll();
      diceEl.textContent = roll;

      if(wouldOvershoot(botPos, roll)){
        const need = CELL_COUNT - botPos;
        logMsg(`Bot rolled ${roll} (needs ${need}). Overshoot â€” turn skipped.`);
        playerTurn = true;
        setStatus('Your turn');
        return;
      }

      logMsg('Bot rolled ' + roll);
      const next = Math.min(CELL_COUNT, botPos + roll);
      await animateTokenStepwise(botToken, botPos, next);
      botPos = next;

      const res = applyFeature(botPos);
      if(res.type){
        logMsg(`Bot hit ${res.type === 'ladder' ? 'a ladder (+15)' : 'a snake (-10)'}`);
        await animateSlide(botToken, botPos, res.next);
        botPos = res.next;
        playBeep(res.type === 'ladder' ? 880 : 240, 200);
      }

      placeTokens();
      if(botPos >= CELL_COUNT){
        endGame('bot');
        return;
      }
      playerTurn = true;
      setStatus('Your turn');
    }

    function endGame(winner){
      running = false;
      rollBtn.disabled = true; startBtn.disabled = false;
      const msg = winner === 'player' ? 'You win! ðŸŽ‰' : 'Bot wins â€” try again!';
      setStatus(msg);
      logMsg(`Game ended â€” winner: ${winner}`);
      if(winner === 'player'){
        showConfetti(3000, 100);
        // credit user (firestore transaction)
        creditReward();
      } else {
        // mark session status as completed (no credit)
        if(currentSessionId){
          const sRef = doc(db, 'snakesSessions', currentSessionId);
          // best-effort update (no need to wait)
          setDoc(sRef, { status: 'completed', credited: false, completedAt: serverTimestamp() }, { merge: true }).catch(()=>{});
        }
      }
    }

    async function playerRoll(){
      if(!running) return;
      if(!playerTurn) return;
      rollBtn.disabled = true;
      let roll = await dramaticRoll();
      diceEl.textContent = roll;

      if(wouldOvershoot(playerPos, roll)){
        const need = CELL_COUNT - playerPos;
        logMsg(`You rolled ${roll} (need ${need}). Overshoot â€” turn skipped.`);
        playerTurn = false;
        await wait(400);
        await botMove();
        rollBtn.disabled = !playerTurn;
        return;
      }

      logMsg('You rolled ' + roll);
      const next = Math.min(CELL_COUNT, playerPos + roll);
      await animateTokenStepwise(playerToken, playerPos, next);
      playerPos = next;

      const res = applyFeature(playerPos);
      if(res.type){
        logMsg(`${res.type === 'ladder' ? 'Ladder (+15)' : 'Snake (-10)'} encountered`);
        await animateSlide(playerToken, playerPos, res.next);
        playerPos = res.next;
        playBeep(res.type === 'ladder' ? 880 : 240, 200);
      }

      placeTokens();
      if(playerPos >= CELL_COUNT){
        endGame('player');
        return;
      }

      playerTurn = false;
      await wait(420);
      await botMove();
      rollBtn.disabled = !playerTurn;
    }

    function resetGame(){
      playerPos = 1; botPos = 1; playerTurn = true; running = false; rollBtn.disabled = true; startBtn.disabled = false; diceEl.textContent = 'â€”'; logEl.innerHTML = ''; setStatus('Press Start to begin'); feeTaken = false; currentSessionId = null; placeTokens();
    }

    async function startGame(){
      // require sign-in and charge entry fee
      if(!currentUser){
        alert('Please sign in to play.');
        return;
      }
      try {
        await chargeEntryFee(); // this will throw if insufficient funds
      } catch(e){
        return; // aborted
      }

      // start actual gameplay
      playerPos = 1; botPos = 1; logEl.innerHTML = '';
      playerTurn = Math.random() < 0.5;
      running = true; rollBtn.disabled = false; startBtn.disabled = true;
      logMsg(`New game started â€” ${playerTurn ? 'You start' : 'Bot starts'}`);
      placeTokens();
      setStatus(playerTurn ? 'Your turn' : 'Bot is moving...');
      await wait(300);
      if(!playerTurn) await botMove();
    }

    // Save result to Firestore (manual save)
    async function saveResultToFirebase(winner){
      try{
        await addDoc(collection(db,'snakesAndLaddersResults'), {
          winner, playerPos, botPos, sessionId: currentSessionId || null, feeCharged: feeTaken?ENTRY_FEE:0, rewardGiven: (winner==='player' ? REWARD : 0), ts: serverTimestamp(), user: currentUser ? (currentUser.uid || currentUser.email || null) : null
        });
        alert('Result saved to Firebase');
      }catch(e){
        console.warn('save failed', e);
        alert('Could not save result: ' + (e.message || e));
      }
    }

    // confetti
    function showConfetti(durationMs = 3000, count = 80){
      confettiRoot.style.display = 'block';
      confettiRoot.innerHTML = '';
      const colors = ['#ff3b3b','#ffb86b','#ffd166','#6ee7b7','#7a5fff','#35d6b1','#fff'];
      for(let i=0;i<count;i++){
        const el = document.createElement('div');
        el.className = 'confetti';
        el.style.background = colors[Math.floor(Math.random()*colors.length)];
        el.style.left = (Math.random()*100) + '%';
        el.style.top = (-10 - Math.random()*20) + 'vh';
        el.style.width = (6 + Math.random()*12) + 'px';
        el.style.height = (8 + Math.random()*16) + 'px';
        el.style.opacity = (0.75 + Math.random()*0.3);
        const speed = 2000 + Math.random()*3600;
        el.style.animationDuration = (speed) + 'ms';
        el.style.transform = `rotate(${Math.floor(Math.random()*360)}deg)`;
        confettiRoot.appendChild(el);
      }
      setTimeout(()=>{ confettiRoot.style.display='none'; confettiRoot.innerHTML=''; }, durationMs + 400);
    }

    // UI wiring
    rollBtn.addEventListener('click', ()=>{ if(!isRolling) playerRoll(); });
    startBtn.addEventListener('click', async ()=>{
      resetGame(); buildBoard(); placeTokens();
      await startGame();
    });
    saveBtn.addEventListener('click', async ()=>{
      if(running) return alert('Save after the game ends');
      const winner = playerPos >= CELL_COUNT ? 'player' : (botPos >= CELL_COUNT ? 'bot' : 'none');
      if(winner === 'none') return alert('Game not finished yet');
      await saveResultToFirebase(winner);
    });

    // init
    buildBoard();
    resetGame();
    placeTokens();

    onAuthStateChanged(auth, user => { currentUser = user; });

    // keyboard
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){ if(!rollBtn.disabled) playerRoll(); e.preventDefault(); }
    });
  </script>
</body>
</html>
