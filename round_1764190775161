<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Current Affairs Quiz</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet"/>
  <style>
    :root{
      --bg-1:#0b0613; --bg-2:#0f0820; --panel:rgba(255,255,255,0.03); --muted:rgba(255,255,255,0.62);
      --text:#eaf2ff; --accent-grad:linear-gradient(135deg,#8446ff,#5b3bff 45%,#6ce2c8 100%);
      --success:#10b981; --danger:#ef4444;
      font-family:'Poppins',system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background: radial-gradient(1000px 600px at 10% 10%, rgba(123,61,255,0.10), transparent), linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text);}
    .phone{max-width:420px;width:100%;margin:20px auto;border-radius:20px;padding:18px 18px 120px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 18px 60px rgba(0,0,0,0.6)}
    .top{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    .avatar{width:56px;height:56px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:18px;color:#041219;background:var(--accent-grad)}
    .greeting h2{margin:0;font-size:16px;font-weight:700}
    .greeting p{margin:6px 0 0;color:var(--muted);font-size:12px}
    .card{margin-top:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid rgba(255,255,255,0.02)}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .center{display:flex;align-items:center;justify-content:center}
    .hidden{display:none}
    .pill{padding:10px;border-radius:999px;text-align:center;font-weight:800;cursor:pointer;border:1px solid rgba(255,255,255,0.04)}
    .primary{background:linear-gradient(90deg,#7a5fff,#35d6b1);color:#041219}
    .ghost{background:transparent;color:var(--muted)}
    /* quiz UI */
    .quiz-header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .score{font-weight:800}
    .timer{font-weight:800}
    .question{font-weight:800;font-size:16px;margin-top:12px}
    .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .choice{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
    .choice.disabled{opacity:.6;pointer-events:none}
    .choice.correct{background:rgba(16,185,129,0.08);border-color:rgba(16,185,129,0.6)}
    .choice.wrong{background:rgba(239,68,68,0.06);border-color:rgba(239,68,68,0.8)}
    .btn{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,#7a5fff,#5e47ff);color:#041219;font-weight:800;cursor:pointer}
    .btn-ghost{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);cursor:pointer}
    .note{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="phone" role="main" aria-live="polite">
    <div class="top">
      <div class="avatar" id="avatar">U</div>
      <div class="greeting">
        <h2 id="greeting">Hi, User</h2>
        <p id="uidline">UID: -</p>
      </div>
      <div style="margin-left:auto" class="center">
        <div class="muted">Category: <strong id="category">Current Affairs</strong></div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:800">Current Affairs Quiz</div>
      <div class="muted small">10 questions • 10s each • Correct: +10 • Wrong: −5</div>
      <div class="note">You can refresh the page — the quiz will resume where you left off and the countdown continues.</div>

      <div class="action-row" style="margin-top:12px;display:flex;gap:8px;">
        <div id="playBtn" class="pill primary">Play</div>
        <div id="rulesBtn" class="pill ghost">Rules</div>
      </div>
    </div>

    <div id="quizCard" class="card hidden" aria-live="polite">
      <div class="quiz-header">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="timer">Time left: <span id="timer">10</span>s</div>
      </div>

      <div id="questionArea"></div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
        <div class="muted small" id="progress">Question 0 / 10</div>
        <div>
          <button id="nextBtn" class="btn-ghost hidden">Next</button>
          <button id="endBtn" class="btn-ghost">End</button>
        </div>
      </div>
    </div>

    <div id="resultCard" class="card hidden">
      <div style="font-weight:900">Quiz complete</div>
      <div id="finalSummary" class="muted small" style="margin-top:8px"></div>
      <div style="margin-top:12px" class="center">
        <button id="closeBtn" class="btn">Close</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="font-weight:800">Your attempts</div>
      <div id="attemptsNote" class="muted small" style="margin-top:8px"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, updateDoc, addDoc, collection, getDocs, query, where, limit, serverTimestamp, runTransaction, arrayUnion
    } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // same config as your dashboard (beni-wealths)
    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    try { await setPersistence(auth, browserLocalPersistence); } catch(e){ /* ignore */ }

    // UI refs
    const avatarEl = document.getElementById('avatar');
    const greetingEl = document.getElementById('greeting');
    const uidLine = document.getElementById('uidline');
    const playBtn = document.getElementById('playBtn');
    const rulesBtn = document.getElementById('rulesBtn');

    const quizCard = document.getElementById('quizCard');
    const questionArea = document.getElementById('questionArea');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const progressEl = document.getElementById('progress');
    const nextBtn = document.getElementById('nextBtn');
    const endBtn = document.getElementById('endBtn');

    const resultCard = document.getElementById('resultCard');
    const finalSummary = document.getElementById('finalSummary');
    const closeBtn = document.getElementById('closeBtn');

    const attemptsNote = document.getElementById('attemptsNote');

    // rules & runtime
    const QUIZ_ID = 'current_affairs_001';
    const QUESTIONS_COUNT = 10;
    const TIME_PER_QUESTION = 10;
    const POINTS_CORRECT = 10;
    const POINTS_WRONG = -5;

    let currentUser = null;
    let attemptRef = null;
    let attemptData = null;
    let questions = [];
    let timer = null;
    let timeLeft = TIME_PER_QUESTION;

    document.getElementById('category').textContent = 'Current Affairs';

    // current affairs placeholder questions (assistant-sourced)
    const placeholder = [
      { id:'c1', text:'Which country hosted COP28 in 2023?', choices:['United Arab Emirates','Egypt','Chile','South Africa'], answerIndex:0 },
      { id:'c2', text:'Who became the UK Prime Minister in 2024? (name as known publicly)', choices:['Rishi Sunak','Keir Starmer','Boris Johnson','Liz Truss'], answerIndex:1 },
      { id:'c3', text:'In 2024, which technology company announced a major AI model named "Gemini" (by brand)?', choices:['OpenAI','Google','Microsoft','Meta'], answerIndex:1 },
      { id:'c4', text:'Which African country discovered a large offshore oil field in 2024 (reported widely)?', choices:['Senegal','Nigeria','Gabon','Mozambique'], answerIndex:0 },
      { id:'c5', text:'Which global event was postponed or significantly affected by the 2024 geopolitical tensions?', choices:['Olympics','World Cup','G7 Summit','EU Summit'], answerIndex:2 },
      { id:'c6', text:'Which currency experienced large volatility in 2024 following interest rate shifts?', choices:['US Dollar','Argentine Peso','Japanese Yen','Nigerian Naira'], answerIndex:2 },
      { id:'c7', text:'Which country legalized a major reform on digital privacy in 2024 (example)?', choices:['European Union (as bloc)','India','Canada','Australia'], answerIndex:0 },
      { id:'c8', text:'Which Middle Eastern country brokered a normalization deal in recent years (2023–2024)?', choices:['Saudi Arabia','Qatar','UAE','Turkey'], answerIndex:2 },
      { id:'c9', text:'Which global leader announced a major climate finance pledge in 2024?', choices:['US President','UK PM','EU Commission President','Chinese Premier'], answerIndex:0 },
      { id:'c10', text:'Which technology trend dominated 2024 headlines?', choices:['Web3','Generative AI','Blockchain games','Smart glasses'], answerIndex:1 }
    ];
    questions = placeholder.slice(0, QUESTIONS_COUNT);

    // helper: local pending queue key
    function pendingKey() { return currentUser ? `bw_quiz_pending_${QUIZ_ID}_${currentUser.uid}` : null; }

    // flush pending answers that failed earlier
    async function flushPending() {
      try {
        const key = pendingKey();
        if(!key) return;
        const raw = localStorage.getItem(key);
        if(!raw) return;
        const list = JSON.parse(raw);
        if(!Array.isArray(list) || list.length === 0) return;
        if(!attemptRef) {
          // try to find attempt
          await loadResumeAttempt();
          if(!attemptRef) return;
        }
        for(const item of list) {
          try {
            // try append using runTransaction with arrayUnion
            await runTransaction(db, async (tx) => {
              const snap = await tx.get(attemptRef);
              if(!snap.exists()) throw new Error('attempt-missing');
              tx.update(attemptRef, {
                score: item.score,
                answers: arrayUnion(item.answer),
                currentIndex: item.currentIndex,
                status: item.status,
                questionStartAt: item.nextQuestionStartAt ? serverTimestamp() : serverTimestamp()
              });
            });
            // remove item if succeeded
            // eslint-disable-next-line no-console
            console.info('flushed pending answer', item);
          } catch(e) {
            console.warn('flush pending item failed', e);
            // stop trying further to avoid infinite loop
            return;
          }
        }
        localStorage.removeItem(key);
      } catch(e) { console.warn('flushPending error', e); }
    }

    // on auth
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if(!user){
        greetingEl.textContent = 'Hi, User';
        avatarEl.textContent = 'U';
        uidLine.textContent = 'UID: -';
        attemptsNote.textContent = 'Sign in on the main site to play.';
        return;
      }
      greetingEl.textContent = user.displayName || (user.email ? user.email.split('@')[0] : 'User');
      avatarEl.textContent = (user.displayName || user.email || 'U')[0].toUpperCase();
      uidLine.textContent = 'UID: ' + user.uid.slice(0,6);
      // check for in-progress attempt and pending flush
      await loadResumeAttempt();
      await flushPending();
      // show count of previous completed attempts
      await loadAttemptsNote();
    });

    // create attempt (no fee, simple addDoc)
    playBtn.addEventListener('click', async () => {
      if(!currentUser) return alert('Sign in on the main site first.');
      const completed = await hasCompleted();
      if(completed) return alert('You already completed this quiz (one completed attempt only).');
      const inprog = await hasInProgress();
      if(inprog){ await loadResumeAttempt(); showQuizUI(); return; }

      if(!confirm('Start the Current Affairs quiz?')) return;

      try {
        const payload = {
          quizId: QUIZ_ID,
          userId: currentUser.uid,
          userEmail: currentUser.email || null,
          currentIndex: 0,
          score: 0,
          status: 'in_progress',
          questionStartAt: serverTimestamp(),
          startedAt: serverTimestamp(),
          answers: []
        };
        const ref = await addDoc(collection(db,'quizAttempts'), payload);
        attemptRef = doc(db,'quizAttempts', ref.id);
        const snap = await getDoc(attemptRef);
        attemptData = snap.data();
        saveLocalSnapshot();
        showQuizUI();
      } catch(e){
        console.error('start failed', e);
        alert('Could not start quiz: ' + (e.message || e));
      }
    });

    // helpers to detect attempts
    async function hasCompleted(){
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','completed'), limit(1));
        const snaps = await getDocs(q);
        return !snaps.empty;
      } catch(e) { return false; }
    }
    async function hasInProgress(){
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','in_progress'), limit(1));
        const snaps = await getDocs(q);
        return !snaps.empty;
      } catch(e) { return false; }
    }

    // load resume attempt
    async function loadResumeAttempt(){
      attemptRef = null;
      attemptData = null;
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','in_progress'), limit(1));
        const snaps = await getDocs(q);
        if(!snaps.empty){
          attemptRef = snaps.docs[0].ref;
          attemptData = snaps.docs[0].data();
          await reconcileExpired();
          showQuizUI();
        }
      } catch(e){ console.warn('loadResumeAttempt', e); }
    }

    // reconcile expired questions
    async function reconcileExpired(){
      if(!attemptData || !attemptRef) return;
      const qsa = attemptData.questionStartAt;
      if(!qsa || !qsa.seconds){
        try { await updateDoc(attemptRef, { questionStartAt: serverTimestamp() }); const s = await getDoc(attemptRef); attemptData = s.data(); } catch(e){}
        return;
      }
      const nowSeconds = Math.floor(Date.now()/1000);
      const startSeconds = qsa.seconds;
      const elapsed = nowSeconds - startSeconds;
      const expired = Math.floor(elapsed / TIME_PER_QUESTION);
      if(expired <= 0) return;
      let newIndex = (attemptData.currentIndex || 0) + expired;
      let newScore = (attemptData.score || 0) + (expired * POINTS_WRONG);
      const nowIso = new Date().toISOString();
      const timeoutAnswers = [];
      for(let i=0;i<expired && (attemptData.currentIndex + i) < QUESTIONS_COUNT;i++){
        timeoutAnswers.push({ qIndex: attemptData.currentIndex + i, selectedIndex: null, correct: false, timedOut: true, ts: nowIso });
      }

      try {
        // append timeouts using arrayUnion inside transaction
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(attemptRef);
          if(!snap.exists()) throw new Error('attempt-missing');
          tx.update(attemptRef, {
            score: newScore,
            currentIndex: newIndex >= QUESTIONS_COUNT ? QUESTIONS_COUNT : newIndex,
            answers: arrayUnion(...timeoutAnswers),
            status: newIndex >= QUESTIONS_COUNT ? 'completed' : 'in_progress',
            completedAt: newIndex >= QUESTIONS_COUNT ? serverTimestamp() : undefined,
            questionStartAt: newIndex >= QUESTIONS_COUNT ? null : serverTimestamp()
          });
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        if(attemptData.status === 'completed') showFinal();
      } catch(e){
        console.warn('reconcile transaction failed', e);
      }
    }

    // show quiz UI
    function showQuizUI(){
      if(!attemptData) return;
      quizCard.classList.remove('hidden');
      resultCard.classList.add('hidden');
      renderCurrentQuestion();
      const qsa = attemptData.questionStartAt;
      let elapsed = 0;
      if(qsa && qsa.seconds) elapsed = Math.floor(Date.now()/1000) - qsa.seconds;
      timeLeft = TIME_PER_QUESTION - (elapsed % TIME_PER_QUESTION);
      if(timeLeft <= 0) timeLeft = 1;
      startTimer();
      saveLocalSnapshot();
    }

    function renderCurrentQuestion(){
      const idx = attemptData.currentIndex || 0;
      if(idx >= QUESTIONS_COUNT){ showFinal(); return; }
      const q = questions[idx];
      questionArea.innerHTML = `<div class="question">${q.text}</div>`;
      const wrap = document.createElement('div'); wrap.className = 'choices';
      q.choices.forEach((c,i) => {
        const el = document.createElement('div');
        el.className = 'choice';
        el.textContent = c;
        el.dataset.index = i;
        el.addEventListener('click', () => answerChoice(i));
        wrap.appendChild(el);
      });
      questionArea.appendChild(wrap);
      scoreEl.textContent = attemptData.score ?? 0;
      progressEl.textContent = `Question ${ (idx+1) } / ${QUESTIONS_COUNT}`;
      nextBtn.classList.add('hidden');
    }

    function startTimer(){
      clearInterval(timer);
      timerEl.textContent = timeLeft;
      timer = setInterval(async () => {
        timeLeft--;
        timerEl.textContent = timeLeft;
        if(timeLeft <= 0){
          clearInterval(timer);
          await handleTimeout();
        }
      },1000);
    }

    // answer handling with robust fallback
    async function answerChoice(selectedIndex){
      clearInterval(timer);
      const idx = attemptData.currentIndex || 0;
      const q = questions[idx];
      const correct = selectedIndex === q.answerIndex;
      const newScore = (attemptData.score || 0) + (correct ? POINTS_CORRECT : POINTS_WRONG);
      const nowIso = new Date().toISOString();
      const answerObj = { qIndex: idx, selectedIndex, correct, timedOut: false, ts: nowIso };
      const willFinish = (idx + 1) >= QUESTIONS_COUNT;

      // optimistic UI disabling
      const choiceEls = questionArea.querySelectorAll('.choice');
      choiceEls.forEach(c=>c.classList.add('disabled'));

      // First try updateDoc with arrayUnion (fast)
      try {
        await updateDoc(attemptRef, {
          score: newScore,
          answers: arrayUnion(answerObj),
          currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
          status: willFinish ? 'completed' : 'in_progress',
          questionStartAt: willFinish ? null : serverTimestamp(),
          completedAt: willFinish ? serverTimestamp() : undefined
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        applyAnswerFeedback(selectedIndex, q, correct);
        if(attemptData.status === 'completed') showFinal();
        else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { renderCurrentQuestion(); }; }
        return;
      } catch (e) {
        console.warn('updateDoc append failed, trying transaction', e);
      }

      // Fallback: try transaction append (atomic)
      try {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(attemptRef);
          if(!snap.exists()) throw new Error('attempt-missing');
          tx.update(attemptRef, {
            score: newScore,
            answers: arrayUnion(answerObj),
            currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
            status: willFinish ? 'completed' : 'in_progress',
            questionStartAt: willFinish ? null : serverTimestamp(),
            completedAt: willFinish ? serverTimestamp() : undefined
          });
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        applyAnswerFeedback(selectedIndex, q, correct);
        if(attemptData.status === 'completed') showFinal();
        else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { renderCurrentQuestion(); }; }
        return;
      } catch(e) {
        console.warn('transaction fallback failed', e);
      }

      // Last resort: queue locally so it won't block the UI
      queuePendingAnswer({ answer: answerObj, score: newScore, currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1), status: willFinish ? 'completed' : 'in_progress' });
      applyAnswerFeedback(selectedIndex, q, correct, true);
      if(willFinish) showFinal();
      else nextBtn.classList.remove('hidden');
    }

    function applyAnswerFeedback(selectedIndex, q, correct, queued=false){
      const choiceEls = questionArea.querySelectorAll('.choice');
      if(choiceEls[selectedIndex]) choiceEls[selectedIndex].classList.add(correct ? 'correct' : 'wrong');
      if(!correct && choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
      const fb = document.createElement('div'); fb.style.marginTop='8px'; fb.style.fontWeight=700;
      fb.style.color = correct ? 'var(--success)' : 'var(--danger)';
      fb.textContent = correct ? `Correct! +${POINTS_CORRECT}` : `Wrong — ${POINTS_WRONG}. Correct: ${q.choices[q.answerIndex]}`;
      if(queued) fb.textContent += ' (queued — will sync)';
      questionArea.appendChild(fb);
      // update displayed score optimistically
      scoreEl.textContent = (attemptData && attemptData.score !== undefined) ? attemptData.score : (queued ? (Number(scoreEl.textContent)||0) + (correct ? POINTS_CORRECT : POINTS_WRONG) : scoreEl.textContent);
    }

    async function handleTimeout(){
      const idx = attemptData.currentIndex || 0;
      const q = questions[idx];
      const newScore = (attemptData.score || 0) + POINTS_WRONG;
      const nowIso = new Date().toISOString();
      const answerObj = { qIndex: idx, selectedIndex: null, correct: false, timedOut: true, ts: nowIso };
      const willFinish = (idx + 1) >= QUESTIONS_COUNT;

      try {
        await updateDoc(attemptRef, {
          score: newScore,
          answers: arrayUnion(answerObj),
          currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
          status: willFinish ? 'completed' : 'in_progress',
          questionStartAt: willFinish ? null : serverTimestamp(),
          completedAt: willFinish ? serverTimestamp() : undefined
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        revealTimeout(q);
        if(attemptData.status === 'completed') showFinal();
        else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { renderCurrentQuestion(); }; }
        return;
      } catch(e){
        console.warn('timeout update failed, trying tx', e);
      }

      try {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(attemptRef);
          if(!snap.exists()) throw new Error('attempt-missing');
          tx.update(attemptRef, {
            score: newScore,
            answers: arrayUnion(answerObj),
            currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
            status: willFinish ? 'completed' : 'in_progress',
            questionStartAt: willFinish ? null : serverTimestamp(),
            completedAt: willFinish ? serverTimestamp() : undefined
          });
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        revealTimeout(q);
        if(attemptData.status === 'completed') showFinal();
        else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { renderCurrentQuestion(); }; }
        return;
      } catch(e){
        console.warn('timeout transaction failed', e);
      }

      // fallback queue
      queuePendingAnswer({ answer: answerObj, score: newScore, currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1), status: willFinish ? 'completed' : 'in_progress' });
      revealTimeout(q, true);
      if(willFinish) showFinal(); else nextBtn.classList.remove('hidden');
    }

    function revealTimeout(q, queued=false){
      const choiceEls = questionArea.querySelectorAll('.choice');
      if(choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
      const fb = document.createElement('div'); fb.style.marginTop='8px'; fb.style.fontWeight=700; fb.style.color='var(--danger)';
      fb.textContent = `Time expired — ${POINTS_WRONG}. Correct: ${q.choices[q.answerIndex]}` + (queued ? ' (queued — will sync)' : '');
      questionArea.appendChild(fb);
      scoreEl.textContent = attemptData && attemptData.score !== undefined ? attemptData.score : scoreEl.textContent;
    }

    // queue pending answers locally
    function queuePendingAnswer(item){
      try {
        const key = pendingKey();
        if(!key) return;
        const raw = localStorage.getItem(key);
        const list = raw ? JSON.parse(raw) : [];
        list.push(item);
        localStorage.setItem(key, JSON.stringify(list));
      } catch(e){ console.warn('queuePendingAnswer failed', e); }
    }

    // end early
    endBtn.addEventListener('click', async () => {
      if(!attemptRef) return;
      if(!confirm('End quiz early? This will save your current score.')) return;
      try {
        await updateDoc(attemptRef, { status: 'completed', completedAt: serverTimestamp() });
        const s = await getDoc(attemptRef); attemptData = s.data();
        showFinal();
      } catch(e){ console.error('end early failed', e); alert('Failed to end early'); }
    });

    function showFinal(){
      clearInterval(timer);
      quizCard.classList.add('hidden');
      resultCard.classList.remove('hidden');
      finalSummary.innerHTML = `<div style="font-weight:800">Your score: ${attemptData ? attemptData.score ?? 0 : 0}</div><div class="muted small" style="margin-top:8px">Thanks for playing Current Affairs.</div>`;
      clearLocalSnapshot();
    }

    closeBtn.addEventListener('click', () => resultCard.classList.add('hidden'));

    // small local snapshot to accelerate resume
    function localKey(){ return currentUser ? `bw_quiz_snap_${QUIZ_ID}_${currentUser.uid}` : null; }
    function saveLocalSnapshot(){
      try {
        const key = localKey(); if(!key || !attemptData || !attemptRef) return;
        const payload = { attemptId: attemptRef.id, currentIndex: attemptData.currentIndex, score: attemptData.score, status: attemptData.status, questionStartAtMs: attemptData.questionStartAt && attemptData.questionStartAt.seconds ? attemptData.questionStartAt.seconds*1000 : Date.now() };
        localStorage.setItem(key, JSON.stringify(payload));
      } catch(e){}
    }
    function clearLocalSnapshot(){ try{ const k = localKey(); if(k) localStorage.removeItem(k); }catch(e){} }

    // attempts note: show count of completed attempts
    async function loadAttemptsNote(){
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','completed'), limit(10));
        const snaps = await getDocs(q);
        attemptsNote.textContent = `Completed attempts: ${snaps.size}`;
      } catch(e){ attemptsNote.textContent = 'Could not load attempts count'; }
    }

    // initial UI
    scoreEl.textContent = '0';
    timerEl.textContent = String(TIME_PER_QUESTION);
    progressEl.textContent = `Question 0 / ${QUESTIONS_COUNT}`;
    attemptsNote.textContent = 'Sign in to track attempts.';

    // try flush pending on load (if user session already exists, onAuthStateChanged will do it)
    (async ()=>{ if(auth.currentUser){ await flushPending(); } })();

  </script>
</body>
</html>
