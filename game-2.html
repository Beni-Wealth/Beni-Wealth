<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Spin the Wheel (responsive)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300,400,600,700&display=swap" rel="stylesheet"/>

  <style>
    :root{
      --bg-1:#071021; --bg-2:#0d1224; --muted:rgba(255,255,255,0.66); --text:#eaf2ff;
      --accent:#7a5fff; --success:#10b981; --danger:#ef4444;
      font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(800px 400px at 10% 10%, rgba(122,95,255,0.06), transparent), linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text);}
    .wrap{max-width:980px;margin:20px auto;padding:16px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:16px; border:1px solid rgba(255,255,255,0.02)}
    header{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:12px}
    .brand{display:flex;gap:12px;align-items:center}
    .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#35d6b1);display:grid;place-items:center;color:#041219;font-weight:800;box-shadow:0 10px 30px rgba(58,40,110,0.35)}
    h1{margin:0;font-size:18px}
    .muted{color:var(--muted);font-size:13px}
    .controls{display:flex;gap:12px;align-items:center}
    .btn{background:linear-gradient(90deg,var(--accent),#35d6b1); border:0;padding:10px 14px;border-radius:10px;color:#041219;font-weight:800;cursor:pointer;box-shadow:0 10px 30px rgba(58,40,110,0.18)}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06); color:var(--text); box-shadow:none}
    .layout{display:flex;gap:20px;flex-wrap:wrap;margin-top:16px}
    .left{flex:1;min-width:260px;display:flex;flex-direction:column;align-items:center;gap:12px}
    .right{width:340px;min-width:260px}

    /* Responsive wheel sizing: use viewport-friendly units on small screens */
    .wheel-wrap{
      width:min(92vw,360px);
      height:min(92vw,360px);
      border-radius:50%;
      display:grid;place-items:center;
      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.008));
      box-shadow:0 18px 60px rgba(0,0,0,0.6);position:relative;overflow:visible;
    }
    canvas#wheel{width:100%;height:100%;border-radius:50%;touch-action:none;display:block;max-width:100%;aspect-ratio:1/1}

    /* needle above the wheel sized responsively using clamp */
    .needle{position:absolute;top:-10%;left:50%;transform:translateX(-50%);z-index:30;width:0;height:0;border-left:clamp(12px,3.2vw,18px) solid transparent;border-right:clamp(12px,3.2vw,18px) solid transparent;border-bottom:clamp(24px,6.5vw,36px) solid #ffffff;border-radius:4px;filter:drop-shadow(0 6px 18px rgba(0,0,0,0.5))}

    .status{margin-top:8px;font-weight:700}
    .balance{font-weight:800;font-size:20px}
    .log{margin-top:12px;max-height:300px;overflow:auto;padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);font-size:13px}
    .log-item{padding:8px;border-radius:8px;margin-bottom:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));display:flex;justify-content:space-between;gap:10px}
    .modal{position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:9999}
    .modal .panel{background:linear-gradient(180deg,rgba(255,255,255,0.03), rgba(255,255,255,0.01));padding:18px;border-radius:12px;min-width:300px;text-align:center;border:1px solid rgba(255,255,255,0.03);box-shadow:0 30px 80px rgba(0,0,0,0.6)}
    .result-amount{font-weight:900;font-size:28px;margin:12px 0}
    .muted-note{color:var(--muted);font-size:13px;margin-top:6px}

    @media(max-width:880px){
      .layout{flex-direction:column;align-items:center}
      .right{width:100%}
      /* make sure wheel area shrinks naturally on narrow phones */
      .wheel-wrap{width:min(92vw,320px);height:min(92vw,320px)}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">BW</div>
        <div>
          <h1>Spin the Wheel</h1>
          <div class="muted">Cost: ₦10 per spin — prizes on the wheel</div>
        </div>
      </div>

      <div class="controls" aria-live="polite">
        <button id="backBtn" class="btn ghost" title="Back to mini-games">Back</button>
        <div style="text-align:right">
          <div class="muted">Balance</div>
          <div class="balance" id="balance">₦0.00</div>
        </div>
        <button id="playBtn" class="btn">Play (₦10)</button>
      </div>
    </header>

    <div class="layout">
      <div class="left card">
        <div class="wheel-wrap" aria-hidden="true">
          <canvas id="wheel" width="640" height="640" role="img" aria-label="Prize wheel"></canvas>
          <!-- needle placed inside wheel-wrap so it's visually above the wheel -->
          <div class="needle" id="needle" aria-hidden="true"></div>
        </div>

        <div class="status" id="status">Ready to play</div>
        <div class="muted-note" style="max-width:520px;text-align:center">Play to spin — results are immediate and recorded. Recent spins persist on this browser.</div>
      </div>

      <div class="right">
        <div class="card">
          <div style="font-weight:900">Recent spins</div>
          <div id="recentLog" class="log" aria-live="polite"><div class="muted">No spins yet</div></div>
        </div>

        <div class="card" style="margin-top:12px">
          <div style="font-weight:900">How it works</div>
          <div class="muted-note">Each play deducts ₦10. After deduction the wheel spins and the win (if any) is credited to your account. Transactions are recorded in Firestore and recent spins are cached locally for instant persistence.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- result modal -->
  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="panel">
      <div id="modalText" style="font-weight:800">You won</div>
      <div class="result-amount" id="modalAmount">₦0</div>
      <div id="modalBalance" class="muted-note">Updated balance: ₦0</div>
      <div style="margin-top:12px"><button id="closeModal" class="btn">Close</button></div>
    </div>
  </div>

  <script type="module">
    // Firebase (same as yours)
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, runTransaction, serverTimestamp, collection
    } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };
    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // UI refs
    const canvas = document.getElementById('wheel');
    const playBtn = document.getElementById('playBtn');
    const statusEl = document.getElementById('status');
    const balanceEl = document.getElementById('balance');
    const recentLog = document.getElementById('recentLog');
    const modal = document.getElementById('modal');
    const modalAmount = document.getElementById('modalAmount');
    const modalText = document.getElementById('modalText');
    const modalBalance = document.getElementById('modalBalance');
    const closeModal = document.getElementById('closeModal');
    const backBtn = document.getElementById('backBtn');

    // internal prize probs (hidden from user)
    const SEGMENTS = [
      { label: '₦100', value: 100, prob: 0.05, color: '#ffd700' }, // 5%
      { label: '₦50',  value: 50,  prob: 0.10, color: '#c0c0c0' }, // 10%
      { label: '₦20',  value: 20,  prob: 0.20, color: '#ffe4b5' }, // 20% (reduced)
      { label: '₦5',   value: 5,   prob: 0.25, color: '#a7f3d0' }, // 25%
      { label: '₦0',   value: 0,   prob: 0.40, color: '#f3f4f6' }  // 40% (remaining)
    ];
    const COST = 10;

    // client state
    let currentUser = null;
    let userBalance = 0;
    let currentRotation = 0;
    let spinning = false;

    // canvas setup
    const ctx = canvas.getContext('2d');

    // helper to resize canvas for crisp rendering on high-DPI devices
    function resizeCanvasAndRedraw(){
      const rect = canvas.getBoundingClientRect();
      const DPR = window.devicePixelRatio || 1;
      // set actual pixel size
      canvas.width = Math.max(300, Math.floor(rect.width * DPR));
      canvas.height = Math.max(300, Math.floor(rect.height * DPR));
      // set transform so drawing commands use CSS pixels
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      drawWheel(currentRotation);
    }

    // draw wheel using equal sectors (visual strokes equal)
    function drawWheel(rotation = 0){
      // compute CSS-pixel dimensions (since transform maps DPR)
      const DPR = window.devicePixelRatio || 1;
      const W = canvas.width / DPR;
      const H = canvas.height / DPR;
      const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 10;

      ctx.clearRect(0,0,canvas.width,canvas.height);

      // subtle background glow
      const gBg = ctx.createRadialGradient(cx, cy, radius*0.2, cx, cy, radius*1.4);
      gBg.addColorStop(0, 'rgba(255,255,255,0.04)');
      gBg.addColorStop(1, 'rgba(0,0,0,0.0)');
      ctx.fillStyle = gBg;
      ctx.fillRect(0,0,W,H);

      const sliceCount = SEGMENTS.length;
      const anglePerSlice = (Math.PI * 2) / sliceCount;
      let startAngle = -Math.PI/2 + (rotation * Math.PI/180);

      // draw equal slices
      for(let i = 0; i < sliceCount; i++){
        const seg = SEGMENTS[i];
        const angle = anglePerSlice;
        // nicer gradient for each slice
        const grad = ctx.createLinearGradient(cx + Math.cos(startAngle) * radius * 0.4, cy + Math.sin(startAngle) * radius * 0.4, cx + Math.cos(startAngle+angle) * radius * 0.4, cy + Math.sin(startAngle+angle) * radius * 0.4);
        grad.addColorStop(0, seg.color);
        grad.addColorStop(1, shadeColor(seg.color, -12));
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy, radius, startAngle, startAngle + angle, false);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();

        // equal stroke lines (segment boundaries)
        ctx.strokeStyle = 'rgba(0,0,0,0.22)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.lineTo(cx + Math.cos(startAngle) * radius, cy + Math.sin(startAngle) * radius);
        ctx.stroke();

        // label (rotated)
        const mid = startAngle + angle/2;
        const tx = cx + Math.cos(mid) * (radius * 0.60);
        const ty = cy + Math.sin(mid) * (radius * 0.60);
        ctx.save();
        ctx.translate(tx,ty);
        ctx.rotate(mid + Math.PI/2);
        ctx.fillStyle = '#041219';
        ctx.font = Math.max(12, Math.floor(radius*0.12)) + 'px Poppins, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(seg.label, 0, 0);
        ctx.restore();

        startAngle += angle;
      }

      // outer circle stroke to complete boundary look
      ctx.beginPath();
      ctx.arc(cx,cy, radius, 0, Math.PI*2);
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.stroke();

      // center button
      const centerGrad = ctx.createLinearGradient(cx - 40, cy - 40, cx + 40, cy + 40);
      centerGrad.addColorStop(0, '#ffffff');
      centerGrad.addColorStop(1, '#f0f6ff');
      ctx.beginPath();
      ctx.arc(cx,cy,Math.max(36, radius*0.18),0,Math.PI*2);
      ctx.fillStyle = centerGrad;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      ctx.fillStyle = '#041219';
      ctx.font = '800 ' + Math.max(12, Math.floor(radius*0.13)) + 'px Poppins, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('SPIN', cx, cy + Math.max(4, Math.floor(radius*0.03)));
    }

    // shade helper
    function shadeColor(hex, percent) {
      const c = hex.replace('#','');
      const num = parseInt(c,16);
      let r = (num >> 16) + percent;
      let g = ((num >> 8) & 0x00FF) + percent;
      let b = (num & 0x0000FF) + percent;
      r = Math.max(Math.min(255, r), 0);
      g = Math.max(Math.min(255, g), 0);
      b = Math.max(Math.min(255, b), 0);
      return '#' + ( (1<<24) + (r<<16) + (g<<8) + b ).toString(16).slice(1);
    }

    // weighted pick (internal only)
    function pickSegmentIndex(){
      const r = Math.random();
      let cum = 0;
      for(let i=0;i<SEGMENTS.length;i++){
        cum += SEGMENTS[i].prob;
        if(r < cum) return i;
      }
      return SEGMENTS.length - 1;
    }

    // compute rotation for equal slices (visual alignment)
    function computeRotationToIndex(index){
      const sliceCount = SEGMENTS.length;
      const segAngleDeg = 360 / sliceCount;
      // center angle for selected index (measured clockwise from top)
      const centerAngleDeg = (index * segAngleDeg) + (segAngleDeg / 2);
      const jitter = (Math.random() - 0.5) * (segAngleDeg * 0.6); // keep away from edges
      const fullSpins = Math.floor(Math.random()*3) + 4;
      const finalRotation = fullSpins * 360 + (360 - centerAngleDeg) + jitter;
      return finalRotation;
    }

    // animate rotation by redrawing at given rotation
    function animateSpin(finalDeg, durationMs = 5200){
      return new Promise((resolve) => {
        const start = performance.now();
        const initial = currentRotation % 360;
        const delta = finalDeg - initial;
        spinning = true;
        statusEl.textContent = 'Spinning...';
        playBtn.disabled = true;
        function step(now){
          const t = Math.min(1, (now - start)/durationMs);
          const ease = 1 - Math.pow(1 - t, 3);
          const rot = initial + delta * ease;
          currentRotation = rot;
          drawWheel(rot);
          if(t < 1){
            requestAnimationFrame(step);
          } else {
            spinning = false;
            playBtn.disabled = false;
            resolve();
          }
        }
        requestAnimationFrame(step);
      });
    }

    // format
    function formatN(n){ return '₦' + Number(n||0).toLocaleString('en-NG', {minimumFractionDigits:2, maximumFractionDigits:2}); }

    // recent spins persistence (per-user or guest)
    function recentKey(){
      return 'bw_recent_spins_' + (currentUser ? currentUser.uid : 'guest');
    }
    function loadRecentSpins(){
      try {
        const raw = localStorage.getItem(recentKey());
        recentLog.innerHTML = '';
        if(!raw) { recentLog.innerHTML = '<div class="muted">No spins yet</div>'; return; }
        const list = JSON.parse(raw);
        if(!Array.isArray(list) || list.length===0){ recentLog.innerHTML = '<div class="muted">No spins yet</div>'; return; }
        for(const it of list.slice().reverse()){
          const node = makeLogItemNode(it);
          recentLog.appendChild(node);
        }
      } catch(e){ console.warn('loadRecentSpins failed', e); recentLog.innerHTML = '<div class="muted">No spins yet</div>'; }
    }
    function saveRecentSpin(spin){
      try {
        const key = recentKey();
        const raw = localStorage.getItem(key);
        const list = raw ? JSON.parse(raw) : [];
        list.push(spin);
        while(list.length > 80) list.shift();
        localStorage.setItem(key, JSON.stringify(list));
      } catch(e){ console.warn('saveRecentSpin failed', e); }
    }
    function makeLogItemNode(spin){
      const d = document.createElement('div');
      d.className = 'log-item';
      const left = document.createElement('div');
      left.innerHTML = `<div style="font-weight:800">${formatN(spin.amountWon)}</div><div style="font-size:12px;color:var(--muted)">${spin.when}</div>`;
      const right = document.createElement('div');
      right.style.textAlign='right';
      right.innerHTML = `<div style="font-weight:800;color:${spin.amountWon>0? 'var(--success)':'var(--muted)'}">${spin.result}</div><div style="font-size:12px;color:var(--muted)">${spin.method || ''}</div>`;
      d.appendChild(left); d.appendChild(right);
      return d;
    }
    function appendLogLine(spin){
      saveRecentSpin(spin);
      const node = makeLogItemNode(spin);
      if(recentLog.firstChild && recentLog.firstChild.className === 'muted') recentLog.innerHTML = '';
      recentLog.prepend(node);
      while(recentLog.children.length > 80) recentLog.removeChild(recentLog.lastChild);
    }

    // read & show balance
    async function refreshBalanceDisplay(){
      if(!currentUser) { balanceEl.textContent = formatN(0); return; }
      try {
        const uRef = doc(db, 'users', currentUser.uid);
        const uSnap = await getDoc(uRef);
        if(uSnap.exists()){
          const d = uSnap.data();
          const b = Number(d.balance ?? d.amount ?? 0);
          userBalance = isFinite(b) ? b : 0;
        } else {
          const bRef = doc(db, 'balances', currentUser.uid);
          const bSnap = await getDoc(bRef);
          if(bSnap.exists()){
            const d = bSnap.data();
            const b = Number(d.balance ?? d.amount ?? 0);
            userBalance = isFinite(b) ? b : 0;
          } else {
            userBalance = 0;
          }
        }
        balanceEl.textContent = formatN(userBalance);
      } catch(e){
        console.warn('refreshBalanceDisplay failed', e);
        balanceEl.textContent = formatN(userBalance || 0);
      }
    }

    // auth
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      await refreshBalanceDisplay();
      loadRecentSpins();
      if(!user){ statusEl.textContent = 'Sign in on the main site to play.'; playBtn.disabled = true; } else { statusEl.textContent = 'Ready to play'; playBtn.disabled = false; }
    });

    // BACK button action
    backBtn.addEventListener('click', () => { window.location.href = 'mini-games.html'; });

    // play click
    playBtn.addEventListener('click', async () => {
      if(spinning) return;
      if(!currentUser) return alert('Sign in on the main site first.');
      if(!confirm('Play will cost ₦10. Continue?')) return;

      playBtn.disabled = true;
      statusEl.textContent = 'Charging...';

      // prepare spin doc ref
      const spinsCol = collection(db, 'spins');
      const spinRef = doc(spinsCol);
      const spinId = spinRef.id;

      // charge transaction: read balance and create spin doc atomically
      try {
        await runTransaction(db, async (tx) => {
          const uRef = doc(db, 'users', currentUser.uid);
          const bRef = doc(db, 'balances', currentUser.uid);
          const uSnap = await tx.get(uRef);
          const bSnap = await tx.get(bRef);

          let balance = null;
          let targetRef = null;
          if(uSnap.exists()){
            balance = Number(uSnap.data().balance ?? uSnap.data().amount ?? 0);
            targetRef = uRef;
          } else if(bSnap.exists()){
            balance = Number(bSnap.data().balance ?? bSnap.data().amount ?? 0);
            targetRef = bRef;
          } else {
            balance = 0;
            targetRef = uRef;
          }
          if(isNaN(balance)) balance = 0;
          if(balance < COST) throw new Error('insufficient-funds');
          const newBalance = balance - COST;

          tx.set(targetRef, { balance: newBalance }, { merge: true });
          tx.set(spinRef, {
            userId: currentUser.uid,
            cost: COST,
            amountWon: null,
            status: 'charged',
            createdAt: serverTimestamp()
          });
        });
      } catch(err){
        console.error('charge failed', err);
        if(err.message && err.message.includes('insufficient-funds')){
          alert('Insufficient funds. Please recharge your account.');
        } else {
          alert('Could not charge account: ' + (err.message || err));
        }
        playBtn.disabled = false;
        await refreshBalanceDisplay();
        return;
      }

      statusEl.textContent = 'Spinning...';

      // client-side pick and spin
      const chosenIndex = pickSegmentIndex();
      const finalDeg = computeRotationToIndex(chosenIndex);
      try {
        await animateSpin(finalDeg, 5200);
      } catch(e){ console.warn('spin animate error', e); }

      const prize = SEGMENTS[chosenIndex].value;

      // credit prize & update spin doc
      let serverCreditFailed = false;
      try {
        await runTransaction(db, async (tx) => {
          const uRef = doc(db, 'users', currentUser.uid);
          const bRef = doc(db, 'balances', currentUser.uid);
          const uSnap = await tx.get(uRef);
          const bSnap = await tx.get(bRef);

          let balance = null;
          let targetRef = null;
          if(uSnap.exists()){
            balance = Number(uSnap.data().balance ?? uSnap.data().amount ?? 0);
            targetRef = uRef;
          } else if(bSnap.exists()){
            balance = Number(bSnap.data().balance ?? bSnap.data().amount ?? 0);
            targetRef = bRef;
          } else {
            balance = 0; targetRef = uRef;
          }
          if(isNaN(balance)) balance = 0;
          const newBalance = balance + prize;
          tx.set(targetRef, { balance: newBalance }, { merge: true });

          const sRef = doc(db, 'spins', spinId);
          tx.update(sRef, { amountWon: prize, status: 'completed', completedAt: serverTimestamp() });
        });
      } catch(err){
        console.error('credit failed', err);
        serverCreditFailed = true;
        // still continue — we'll persist local spin record and notify user
      }

      // update local UI & persist recent spin
      await refreshBalanceDisplay();

      const spinRecord = {
        amountWon: prize,
        when: new Date().toLocaleString(),
        result: prize>0 ? 'win' : 'no win',
        method: serverCreditFailed ? 'local-fallback' : 'spin'
      };
      appendLogLine(spinRecord);

      // show modal after balance refreshed
      modalText.textContent = prize > 0 ? 'You won' : 'No win this time';
      modalAmount.textContent = formatN(prize);
      modalBalance.textContent = 'Updated balance: ' + formatN(userBalance);
      modal.style.display = 'flex';
      statusEl.textContent = prize>0 ? `You won ${formatN(prize)}!` : 'No win this time — better luck next spin.';
      playBtn.disabled = false;
    });

    // local fallback record for errors
    function appendLocalSpinRecord(prize, note){
      const spinRecord = { amountWon: prize, when: new Date().toLocaleString(), result: prize>0? 'win' : 'no win', method: (note || 'local') };
      appendLogLine(spinRecord);
    }

    // load persisted recent spins on start
    loadRecentSpins();

    closeModal.addEventListener('click', ()=> { modal.style.display='none'; });

    // auto-refresh balance periodically
    setInterval(()=> { if(currentUser) refreshBalanceDisplay().catch(()=>{}); }, 12000);

    // handle resizing for crisp canvas
    window.addEventListener('resize', () => {
      // debounce small resizes by using requestAnimationFrame
      window.requestAnimationFrame(resizeCanvasAndRedraw);
    });

    // initial resize and draw once DOM is ready
    window.addEventListener('load', () => {
      resizeCanvasAndRedraw();
    });

  </script>
</body>
</html>
