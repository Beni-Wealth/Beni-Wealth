<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Nigerian Quiz (timer carryover)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300,400,600,700&display=swap" rel="stylesheet"/>
  <style>
    :root{
      --bg-1:#0b0613; --bg-2:#0f0820; --muted:rgba(255,255,255,0.62); --text:#eaf2ff;
      --accent-grad:linear-gradient(135deg,#8446ff,#5b3bff 45%,#6ce2c8 100%); --success:#10b981; --danger:#ef4444; --accent:#7a5fff;
      font-family:'Poppins',system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background: radial-gradient(1000px 600px at 10% 10%, rgba(123,61,255,0.10), transparent), linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text);}
    .phone{max-width:420px;width:100%;margin:20px auto;border-radius:20px;padding:18px 18px 120px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 18px 60px rgba(0,0,0,0.6)}
    .top{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    .avatar{width:56px;height:56px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:18px;color:#041219;background:var(--accent-grad)}
    .greeting h2{margin:0;font-size:16px;font-weight:700}
    .greeting p{margin:6px 0 0;color:var(--muted);font-size:12px}
    .card{margin-top:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid rgba(255,255,255,0.02)}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .center{display:flex;align-items:center;justify-content:center}
    .hidden{display:none}
    .pill{padding:10px;border-radius:999px;text-align:center;font-weight:800;cursor:pointer;border:1px solid rgba(255,255,255,0.04)}
    .primary{background:linear-gradient(90deg,#7a5fff,#35d6b1);color:#041219}
    .ghost{background:transparent;color:var(--muted)}
    /* quiz UI */
    .quiz-header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .score{font-weight:800}
    .timer{font-weight:800}
    .question{font-weight:800;font-size:16px;margin-top:12px}
    .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .choice{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
    .choice.disabled{opacity:.6;pointer-events:none}
    .choice.correct{background:rgba(16,185,129,0.12);border-color:rgba(16,185,129,0.6)}
    .choice.wrong{background:rgba(239,68,68,0.08);border-color:rgba(239,68,68,0.8)}
    .feedback{margin-top:8px;padding:8px;border-radius:8px;font-weight:700}
    .feedback.correct{background:rgba(16,185,129,0.10);color: #041219}
    .feedback.wrong{background:rgba(239,68,68,0.08);color:#041219}
    .feedback.timeout{background:rgba(239,68,68,0.06);color:#041219}
    .btn{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,#7a5fff,#5e47ff);color:#041219;font-weight:800;cursor:pointer}
    .btn-ghost{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);cursor:pointer}
    .note{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px}

    /* tracker */
    .tracker { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; align-items:center; }
    .tracker-dot {
      width:34px; height:34px; border-radius:50%; display:grid; place-items:center; font-weight:700; font-size:13px;
      background: rgba(255,255,255,0.02); color:var(--muted); border:2px solid rgba(255,255,255,0.03);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .tracker-dot.current { border-color: var(--accent); transform: scale(1.06); color:#041219; background: linear-gradient(90deg,#fff,#fff0); }
    .tracker-dot.correct { background: rgba(16,185,129,0.14); border-color: rgba(16,185,129,0.6); color: #041219; }
    .tracker-dot.wrong { background: rgba(239,68,68,0.09); border-color: rgba(239,68,68,0.7); color: #041219; }
    .tracker-legend { display:flex; gap:8px; margin-top:8px; align-items:center; color:var(--muted); font-size:12px;}
    .legend-item { display:flex; gap:6px; align-items:center; }
    .legend-swatch { width:12px; height:12px; border-radius:3px; }
    .legend-correct { background: rgba(16,185,129,0.8); }
    .legend-wrong { background: rgba(239,68,68,0.8); }
    .legend-current { border:2px solid var(--accent); background:transparent; width:12px; height:12px; border-radius:3px; }
  </style>
</head>
<body>
  <div class="phone" role="main" aria-live="polite">
    <div class="top">
      <div class="avatar" id="avatar">U</div>
      <div class="greeting">
        <h2 id="greeting">Hi, User</h2>
        <p id="uidline">UID: -</p>
      </div>
      <div style="margin-left:auto" class="center">
        <div class="muted">Category: <strong id="category">General Nigerian</strong></div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:800">General Nigerian Quiz</div>
      <div class="muted small">10 questions • 20s each • Correct: +10 • Wrong: −5</div>
      <div class="note">You can refresh the page — the quiz will resume where you left off and the countdown continues (remaining time carries to next question when you answer).</div>

      <div class="action-row" style="margin-top:12px;display:flex;gap:8px;">
        <div id="playBtn" class="pill primary">Play</div>
        <div id="rulesBtn" class="pill ghost">Rules</div>
      </div>
    </div>

    <div id="quizCard" class="card hidden" aria-live="polite">
      <div class="quiz-header">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="timer">Time left: <span id="timer">20</span>s</div>
      </div>

      <!-- tracker: shows per-question correctness -->
      <div id="tracker" class="tracker" aria-hidden="false"></div>
      <div class="tracker-legend" aria-hidden="false">
        <div class="legend-item"><div class="legend-swatch legend-correct"></div> Correct</div>
        <div class="legend-item"><div class="legend-swatch legend-wrong"></div> Wrong / timed-out</div>
        <div class="legend-item"><div class="legend-swatch legend-current"></div> Current</div>
      </div>

      <div id="questionArea"></div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
        <div class="muted small" id="progress">Question 0 / 10</div>
        <div>
          <button id="nextBtn" class="btn-ghost hidden">Next</button>
          <button id="endBtn" class="btn-ghost">End</button>
        </div>
      </div>
    </div>

    <div id="resultCard" class="card hidden">
      <div style="font-weight:900">Quiz complete</div>
      <div id="finalSummary" class="muted small" style="margin-top:8px"></div>
      <div style="margin-top:12px" class="center">
        <button id="closeBtn" class="btn">Close</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="font-weight:800">Your attempts</div>
      <div id="attemptsNote" class="muted small" style="margin-top:8px"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, updateDoc, addDoc, collection, getDocs, query, where, limit, serverTimestamp, runTransaction, arrayUnion
    } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    try { await setPersistence(auth, browserLocalPersistence); } catch(e){/*ignore*/}

    // UI refs
    const avatarEl = document.getElementById('avatar');
    const greetingEl = document.getElementById('greeting');
    const uidLine = document.getElementById('uidline');
    const playBtn = document.getElementById('playBtn');
    const rulesBtn = document.getElementById('rulesBtn');

    const quizCard = document.getElementById('quizCard');
    const questionArea = document.getElementById('questionArea');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const progressEl = document.getElementById('progress');
    const nextBtn = document.getElementById('nextBtn');
    const endBtn = document.getElementById('endBtn');

    const resultCard = document.getElementById('resultCard');
    const finalSummary = document.getElementById('finalSummary');
    const closeBtn = document.getElementById('closeBtn');

    const attemptsNote = document.getElementById('attemptsNote');
    const trackerEl = document.getElementById('tracker');

    // rules & runtime (changed per request)
    const QUIZ_ID = 'nigeria_general_001';
    const QUESTIONS_COUNT = 10;
    const TIME_PER_QUESTION = 20; // seconds
    const POINTS_CORRECT = 10;
    const POINTS_WRONG = -5;
    const FEEDBACK_DELAY_MS = 1600; // pause after correct/wrong
    const TIMEOUT_FEEDBACK_MS = 2200; // pause after timeout

    let currentUser = null;
    let attemptRef = null;
    let attemptData = null;
    let questions = [];
    let timer = null;
    let timeLeft = TIME_PER_QUESTION; // visible seconds

    document.getElementById('category').textContent = 'General Nigerian';

    // 10 general Nigerian questions
    const placeholder = [
      { id:'n1', text:'What is the capital city of Nigeria?', choices:['Lagos','Abuja','Kano','Port Harcourt'], answerIndex:1 },
      { id:'n2', text:'Which Nigerian city is the largest by population?', choices:['Abuja','Lagos','Kano','Ibadan'], answerIndex:1 },
      { id:'n3', text:'Which river flows through the Niger Delta region?', choices:['Nile','Volta','Niger','Zambezi'], answerIndex:2 },
      { id:'n4', text:'Which festival is famously celebrated in Benin City with coral beads and royal rituals?', choices:['Argungu','Igue','Eyo','Osun-Osogbo'], answerIndex:1 },
      { id:'n5', text:'Who was the first President of independent Nigeria (1963 - as Republic)?', choices:['Nnamdi Azikiwe','Obafemi Awolowo','Ahmadu Bello','Abubakar Tafawa Balewa'], answerIndex:0 },
      { id:'n6', text:'Which Nigerian author wrote "Things Fall Apart"?', choices:['Chinua Achebe','Wole Soyinka','Buchi Emecheta','Ben Okri'], answerIndex:0 },
      { id:'n7', text:'Which language is widely spoken in the southwestern region of Nigeria?', choices:['Hausa','Yoruba','Igbo','Kanuri'], answerIndex:1 },
      { id:'n8', text:'Which Nigerian state is famous for the Jos Plateau?', choices:['Plateau State','Kaduna State','Kogi State','Enugu State'], answerIndex:0 },
      { id:'n9', text:'What is the currency of Nigeria?', choices:['Cedi','Naira','Shilling','Pound'], answerIndex:1 },
      { id:'n10', text:'Which body of water borders southern Nigeria?', choices:['Gulf of Guinea','Red Sea','Atlantic Ocean (North)','Indian Ocean'], answerIndex:0 }
    ];
    questions = placeholder.slice(0, QUESTIONS_COUNT);

    function pendingKey() { return currentUser ? `bw_quiz_pending_${QUIZ_ID}_${currentUser.uid}` : null; }

    async function flushPending() {
      try {
        const key = pendingKey();
        if(!key) return;
        const raw = localStorage.getItem(key); if(!raw) return;
        const list = JSON.parse(raw); if(!Array.isArray(list) || list.length===0) return;
        if(!attemptRef) await loadResumeAttempt();
        if(!attemptRef) return;
        for(const item of list){
          try {
            await runTransaction(db, async (tx) => {
              const snap = await tx.get(attemptRef);
              if(!snap.exists()) throw new Error('attempt-missing');
              tx.update(attemptRef, {
                score: item.score,
                answers: arrayUnion(item.answer),
                currentIndex: item.currentIndex,
                status: item.status,
                // restore the saved client-side carryover time
                questionTimeLeftMs: item.questionTimeLeftMs || (TIME_PER_QUESTION*1000),
                questionTimeLeftUpdatedAt: serverTimestamp()
              });
            });
          } catch(e) { console.warn('flush pending item failed', e); return; }
        }
        localStorage.removeItem(key);
      } catch(e){ console.warn('flushPending err', e); }
    }

    // Helper to compute timeLeft (seconds) from attemptData fields
    function computeTimeLeftFromAttempt(aData){
      try{
        if(!aData) return TIME_PER_QUESTION;
        // prefer explicit stored remaining + timestamp
        if(aData.questionTimeLeftMs !== undefined && aData.questionTimeLeftUpdatedAt){
          const leftMs = Number(aData.questionTimeLeftMs) || 0;
          const updated = aData.questionTimeLeftUpdatedAt;
          if(updated && updated.seconds){
            const elapsed = Date.now() - (updated.seconds * 1000 + Math.floor((updated.nanoseconds||0)/1000000));
            const remain = Math.max(0, leftMs - elapsed);
            const seconds = Math.ceil(remain/1000);
            return seconds > 0 ? seconds : 0;
          }
          return Math.ceil(leftMs/1000) || TIME_PER_QUESTION;
        }
        // fallback: if older "questionStartAt" exists we convert to timeLeft (compat)
        if(aData.questionStartAt && aData.questionStartAt.seconds){
          const startSec = aData.questionStartAt.seconds;
          const elapsed = Math.floor(Date.now()/1000) - startSec;
          const remain = TIME_PER_QUESTION - (elapsed % TIME_PER_QUESTION);
          return remain > 0 ? remain : 1;
        }
      }catch(e){ console.warn('computeTimeLeftFromAttempt failed', e); }
      return TIME_PER_QUESTION;
    }

    // small helper: persist local queue if offline
    function queuePendingAnswer(item){
      try { const key = pendingKey(); if(!key) return; const raw = localStorage.getItem(key); const list = raw ? JSON.parse(raw) : []; list.push(item); localStorage.setItem(key, JSON.stringify(list)); } catch(e){ console.warn('queue failed', e); }
    }

    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if(!user){
        greetingEl.textContent = 'Hi, User'; avatarEl.textContent = 'U'; uidLine.textContent = 'UID: -';
        attemptsNote.textContent = 'Sign in on the main site to play.'; return;
      }
      greetingEl.textContent = user.displayName || (user.email?user.email.split('@')[0]:'User');
      avatarEl.textContent = (user.displayName || user.email || 'U')[0].toUpperCase();
      uidLine.textContent = 'UID: ' + user.uid.slice(0,6);
      await loadResumeAttempt();
      await flushPending();
      await loadAttemptsNote();
    });

    // create attempt
    playBtn.addEventListener('click', async () => {
      if(!currentUser) return alert('Sign in on the main site first.');
      const completed = await hasCompleted(); if(completed) return alert('You already completed this quiz.');
      const inprog = await hasInProgress(); if(inprog){ await loadResumeAttempt(); showQuizUI(); return; }
      if(!confirm('Start the General Nigerian quiz?')) return;

      try {
        const payload = {
          quizId: QUIZ_ID,
          userId: currentUser.uid,
          userEmail: currentUser.email || null,
          currentIndex:0,
          score:0,
          status:'in_progress',
          // start with full time for first question
          questionTimeLeftMs: TIME_PER_QUESTION * 1000,
          questionTimeLeftUpdatedAt: serverTimestamp(),
          startedAt: serverTimestamp(),
          answers:[]
        };
        const ref = await addDoc(collection(db,'quizAttempts'), payload);
        attemptRef = doc(db,'quizAttempts', ref.id);
        const snap = await getDoc(attemptRef); attemptData = snap.data();
        saveLocalSnapshot();
        showQuizUI();
      } catch(e){ console.error('start failed', e); alert('Could not start quiz: ' + (e.message || e)); }
    });

    async function hasCompleted(){
      try { const col = collection(db,'quizAttempts'); const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','completed'), limit(1)); const snaps = await getDocs(q); return !snaps.empty; } catch(e){ return false; }
    }
    async function hasInProgress(){
      try { const col = collection(db,'quizAttempts'); const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','in_progress'), limit(1)); const snaps = await getDocs(q); return !snaps.empty; } catch(e){ return false; }
    }

    async function loadResumeAttempt(){
      attemptRef = null; attemptData = null;
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','in_progress'), limit(1));
        const snaps = await getDocs(q);
        if(!snaps.empty){
          attemptRef = snaps.docs[0].ref;
          attemptData = snaps.docs[0].data();
          // adjust for elapsed using our stored time-left fields
          await reconcileExpired();
          showQuizUI();
        }
      } catch(e){ console.warn('loadResumeAttempt', e); }
    }

    // reconcileExpired: best-effort using questionTimeLeftMs + timestamp
    async function reconcileExpired(){
      if(!attemptData || !attemptRef) return;
      try{
        const qLeftMs = attemptData.questionTimeLeftMs;
        const qUpdated = attemptData.questionTimeLeftUpdatedAt;
        if(qLeftMs !== undefined && qUpdated && qUpdated.seconds){
          const elapsed = Date.now() - (qUpdated.seconds*1000 + Math.floor((qUpdated.nanoseconds||0)/1000000));
          if(elapsed < qLeftMs){
            // still within current question
            return;
          }
          // elapsed covers current question and possibly more; compute how many questions expired
          const overMs = elapsed - qLeftMs; // ms beyond current question
          const expiredCount = 1 + Math.floor(overMs / (TIME_PER_QUESTION*1000));
          if(expiredCount <= 0) return;

          const nowIso = new Date().toISOString();
          const timeoutAnswers = [];
          for(let i=0;i<expiredCount && (attemptData.currentIndex + i) < QUESTIONS_COUNT;i++){
            timeoutAnswers.push({ qIndex: attemptData.currentIndex + i, selectedIndex: null, correct:false, timedOut:true, ts: nowIso });
          }
          let newIndex = (attemptData.currentIndex || 0) + expiredCount;
          let newScore = (attemptData.score || 0) + (expiredCount * POINTS_WRONG);

          // compute leftover ms for next question (if not completed)
          const remainderMs = overMs % (TIME_PER_QUESTION*1000);
          const nextLeftMs = newIndex >= QUESTIONS_COUNT ? 0 : Math.max(0, TIME_PER_QUESTION*1000 - remainderMs);

          await runTransaction(db, async (tx) => {
            const snap = await tx.get(attemptRef);
            if(!snap.exists()) throw new Error('attempt-missing');
            tx.update(attemptRef, {
              score: newScore,
              currentIndex: newIndex >= QUESTIONS_COUNT ? QUESTIONS_COUNT : newIndex,
              answers: arrayUnion(...timeoutAnswers),
              status: newIndex >= QUESTIONS_COUNT ? 'completed' : 'in_progress',
              completedAt: newIndex >= QUESTIONS_COUNT ? serverTimestamp() : undefined,
              questionTimeLeftMs: nextLeftMs,
              questionTimeLeftUpdatedAt: newIndex >= QUESTIONS_COUNT ? null : serverTimestamp()
            });
          });

          const s = await getDoc(attemptRef); attemptData = s.data();
          if(attemptData.status === 'completed') showFinal();
        }
      }catch(e){ console.warn('reconcileExpired failed', e); }
    }

    // RENDER & TIMER
    function showQuizUI(){
      if(!attemptData) return;
      quizCard.classList.remove('hidden'); resultCard.classList.add('hidden');
      renderTracker();
      renderCurrentQuestion();

      // compute timeLeft using stored questionTimeLeftMs + timestamp
      timeLeft = computeTimeLeftFromAttempt(attemptData);
      if(timeLeft <= 0) timeLeft = 1;
      startTimer(); saveLocalSnapshot();
    }

    function renderTracker(){
      // build answers map from attemptData.answers
      const answersArr = (attemptData && Array.isArray(attemptData.answers)) ? attemptData.answers : [];
      const byIndex = {};
      for(const a of answersArr){
        if(a && typeof a.qIndex === 'number') byIndex[a.qIndex] = a;
      }
      trackerEl.innerHTML = '';
      const currentIdx = attemptData ? (attemptData.currentIndex || 0) : 0;
      for(let i=0;i<QUESTIONS_COUNT;i++){
        const dot = document.createElement('div');
        dot.className = 'tracker-dot';
        dot.textContent = (i+1);
        dot.setAttribute('role','img');
        dot.setAttribute('aria-label', `Question ${i+1}`);
        if(i === currentIdx) dot.classList.add('current');
        const ans = byIndex[i];
        if(ans){
          if(ans.correct) dot.classList.add('correct');
          else dot.classList.add('wrong');
          dot.setAttribute('title', `Question ${i+1}: ${ans.correct ? 'correct' : (ans.timedOut ? 'timed out' : 'wrong')}`);
        } else {
          dot.setAttribute('title', `Question ${i+1}: not answered`);
        }
        trackerEl.appendChild(dot);
      }
    }

    function renderCurrentQuestion(){
      const idx = attemptData.currentIndex || 0; if(idx >= QUESTIONS_COUNT){ showFinal(); return; }
      const q = questions[idx];
      questionArea.innerHTML = `<div class="question">${q.text}</div>`;
      const wrap = document.createElement('div'); wrap.className='choices';
      q.choices.forEach((c,i)=>{ const el=document.createElement('div'); el.className='choice'; el.textContent=c; el.dataset.index=i; el.addEventListener('click',()=>answerChoice(i)); wrap.appendChild(el); });
      questionArea.appendChild(wrap);
      scoreEl.textContent = attemptData.score ?? 0;
      progressEl.textContent = `Question ${ (idx+1) } / ${QUESTIONS_COUNT}`;
      nextBtn.classList.add('hidden');

      // update tracker to show current highlight
      renderTracker();
    }

    function startTimer(){
      clearInterval(timer);
      timerEl.textContent = timeLeft;
      timer = setInterval(async ()=>{ timeLeft--; timerEl.textContent = timeLeft; if(timeLeft<=0){ clearInterval(timer); await handleTimeout(); } },1000);
    }

    // Next button fetch latest attempt state (safety-net)
    nextBtn.addEventListener('click', async () => {
      if(!attemptRef) return alert('No active attempt found.');
      try {
        const snap = await getDoc(attemptRef);
        if(!snap.exists()) return alert('Attempt not found.');
        attemptData = snap.data();
        if(attemptData.status === 'completed' || (attemptData.currentIndex || 0) >= QUESTIONS_COUNT) { showFinal(); return; }
        renderTracker();
        renderCurrentQuestion();
        // compute timeLeft from saved fields
        timeLeft = computeTimeLeftFromAttempt(attemptData);
        if(timeLeft <= 0) timeLeft = 1;
        startTimer();
      } catch(e){
        console.error('Next handler failed', e);
        alert('Could not move to next question: ' + (e.message || e));
      }
    });

    // ANSWER HANDLING — carries remaining time to next question
    async function answerChoice(selectedIndex){
      clearInterval(timer);
      const idx = attemptData.currentIndex || 0; const q = questions[idx];
      const correct = selectedIndex === q.answerIndex; const newScore = (attemptData.score || 0) + (correct ? POINTS_CORRECT : POINTS_WRONG);
      const nowIso = new Date().toISOString(); const answerObj = { qIndex: idx, selectedIndex, correct, timedOut:false, ts: nowIso };
      const willFinish = (idx+1) >= QUESTIONS_COUNT;
      const choiceEls = questionArea.querySelectorAll('.choice'); choiceEls.forEach(c=>c.classList.add('disabled'));

      // compute carryover: keep current timeLeft as next question's starting time
      const carryMs = Math.max(0, (timeLeft || 0) * 1000);

      // Try quick updateDoc first and include carryover fields
      try {
        await updateDoc(attemptRef, {
          score: newScore,
          answers: arrayUnion(answerObj),
          currentIndex: willFinish ? QUESTIONS_COUNT : (idx+1),
          status: willFinish ? 'completed' : 'in_progress',
          questionTimeLeftMs: willFinish ? 0 : carryMs,
          questionTimeLeftUpdatedAt: willFinish ? null : serverTimestamp(),
          completedAt: willFinish ? serverTimestamp() : undefined
        });
        // fetch server state and render next after feedback pause
        const s = await getDoc(attemptRef);
        attemptData = s.data();
        applyAnswerFeedback(selectedIndex, q, correct);
        renderTracker();
        if(attemptData.status === 'completed'){
          setTimeout(()=> showFinal(), FEEDBACK_DELAY_MS);
        } else {
          setTimeout(()=> { renderCurrentQuestion();
            // compute timeLeft from stored carryover
            timeLeft = computeTimeLeftFromAttempt(attemptData);
            if(timeLeft <= 0) timeLeft = 1;
            startTimer();
          }, FEEDBACK_DELAY_MS);
        }
        return;
      } catch (e) { console.warn('updateDoc append failed', e); }

      // transaction fallback (same fields)
      try {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(attemptRef);
          if(!snap.exists()) throw new Error('attempt-missing');
          tx.update(attemptRef, {
            score: newScore,
            answers: arrayUnion(answerObj),
            currentIndex: willFinish ? QUESTIONS_COUNT : (idx+1),
            status: willFinish ? 'completed' : 'in_progress',
            questionTimeLeftMs: willFinish ? 0 : carryMs,
            questionTimeLeftUpdatedAt: willFinish ? null : serverTimestamp(),
            completedAt: willFinish ? serverTimestamp() : undefined
          });
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        applyAnswerFeedback(selectedIndex, q, correct);
        renderTracker();
        if(attemptData.status === 'completed'){
          setTimeout(()=> showFinal(), FEEDBACK_DELAY_MS);
        } else {
          setTimeout(()=> { renderCurrentQuestion();
            timeLeft = computeTimeLeftFromAttempt(attemptData);
            if(timeLeft <= 0) timeLeft = 1;
            startTimer();
          }, FEEDBACK_DELAY_MS);
        }
        return;
      } catch(e){ console.warn('transaction failed', e); }

      // Local queue fallback: update local attemptData optimistically and advance UI after feedback pause
      queuePendingAnswer({ answer: answerObj, score: newScore, currentIndex: willFinish ? QUESTIONS_COUNT : (idx+1), status: willFinish ? 'completed' : 'in_progress', questionTimeLeftMs: willFinish ? 0 : carryMs });
      attemptData = attemptData || {};
      attemptData.score = newScore;
      attemptData.currentIndex = willFinish ? QUESTIONS_COUNT : (idx+1);
      attemptData.status = willFinish ? 'completed' : 'in_progress';
      attemptData.questionTimeLeftMs = willFinish ? 0 : carryMs;
      attemptData.questionTimeLeftUpdatedAt = null; // local only
      applyAnswerFeedback(selectedIndex, q, correct, true);
      renderTracker();
      if(attemptData.status === 'completed'){
        setTimeout(()=> showFinal(), FEEDBACK_DELAY_MS);
      } else {
        setTimeout(()=> { renderCurrentQuestion();
          timeLeft = computeTimeLeftFromAttempt(attemptData);
          if(timeLeft <= 0) timeLeft = 1;
          startTimer();
        }, FEEDBACK_DELAY_MS);
      }
    }

    function applyAnswerFeedback(selectedIndex, q, correct, queued=false){
      const choiceEls = questionArea.querySelectorAll('.choice');
      if(choiceEls[selectedIndex]) choiceEls[selectedIndex].classList.add(correct ? 'correct' : 'wrong');
      if(!correct && choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
      const fb = document.createElement('div'); fb.className = 'feedback ' + (correct ? 'correct' : 'wrong');
      fb.textContent = correct ? `Correct! +${POINTS_CORRECT}` : `Wrong — ${POINTS_WRONG}. Correct: ${q.choices[q.answerIndex]}` + (queued ? ' (queued — will sync)' : '');
      questionArea.appendChild(fb);
      scoreEl.textContent = (attemptData && attemptData.score !== undefined) ? attemptData.score : (Number(scoreEl.textContent||0) + (correct ? POINTS_CORRECT : POINTS_WRONG));
    }

    // TIMEOUT handling — show timeout message then advance after a longer pause
    async function handleTimeout(){
      const idx = attemptData.currentIndex || 0; const q = questions[idx];
      const newScore = (attemptData.score || 0) + POINTS_WRONG; const nowIso = new Date().toISOString();
      const answerObj = { qIndex: idx, selectedIndex: null, correct:false, timedOut:true, ts: nowIso };
      const willFinish = (idx+1) >= QUESTIONS_COUNT;

      // show timeout UI immediatelly (before server write) so user sees it
      const choiceEls = questionArea.querySelectorAll('.choice'); choiceEls.forEach(c=>c.classList.add('disabled'));
      const fb = document.createElement('div'); fb.className='feedback timeout';
      fb.textContent = `Time expired — ${POINTS_WRONG}. Correct: ${q.choices[q.answerIndex]}`;
      questionArea.appendChild(fb);
      renderTracker();

      // For timeout we do NOT carry remaining time (next question starts with full TIME_PER_QUESTION)
      const nextLeftMs = willFinish ? 0 : TIME_PER_QUESTION*1000;

      try {
        await updateDoc(attemptRef, {
          score: newScore,
          answers: arrayUnion(answerObj),
          currentIndex: willFinish ? QUESTIONS_COUNT : (idx+1),
          status: willFinish ? 'completed' : 'in_progress',
          questionTimeLeftMs: nextLeftMs,
          questionTimeLeftUpdatedAt: willFinish ? null : serverTimestamp(),
          completedAt: willFinish ? serverTimestamp() : undefined
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        // advance after TIMEOUT_FEEDBACK_MS
        if(attemptData.status === 'completed'){
          setTimeout(()=> showFinal(), TIMEOUT_FEEDBACK_MS);
        } else {
          setTimeout(()=> { renderCurrentQuestion(); timeLeft = computeTimeLeftFromAttempt(attemptData); if(timeLeft<=0) timeLeft=1; startTimer(); }, TIMEOUT_FEEDBACK_MS);
        }
        return;
      } catch(e){ console.warn('timeout update failed', e); }

      try {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(attemptRef); if(!snap.exists()) throw new Error('attempt-missing');
          tx.update(attemptRef, {
            score: newScore,
            answers: arrayUnion(answerObj),
            currentIndex: willFinish ? QUESTIONS_COUNT : (idx+1),
            status: willFinish ? 'completed' : 'in_progress',
            questionTimeLeftMs: nextLeftMs,
            questionTimeLeftUpdatedAt: willFinish ? null : serverTimestamp(),
            completedAt: willFinish ? serverTimestamp() : undefined
          });
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        if(attemptData.status === 'completed'){
          setTimeout(()=> showFinal(), TIMEOUT_FEEDBACK_MS);
        } else {
          setTimeout(()=> { renderCurrentQuestion(); timeLeft = computeTimeLeftFromAttempt(attemptData); if(timeLeft<=0) timeLeft=1; startTimer(); }, TIMEOUT_FEEDBACK_MS);
        }
        return;
      } catch(e){ console.warn('timeout tx failed', e); }

      // queue locally and optimistically advance after delay
      queuePendingAnswer({ answer: answerObj, score: newScore, currentIndex: willFinish ? QUESTIONS_COUNT : (idx+1), status: willFinish ? 'completed' : 'in_progress', questionTimeLeftMs: nextLeftMs });
      attemptData = attemptData || {};
      attemptData.score = newScore;
      attemptData.currentIndex = willFinish ? QUESTIONS_COUNT : (idx+1);
      attemptData.status = willFinish ? 'completed' : 'in_progress';
      attemptData.questionTimeLeftMs = nextLeftMs;
      attemptData.questionTimeLeftUpdatedAt = null;
      if(attemptData.status === 'completed'){
        setTimeout(()=> showFinal(), TIMEOUT_FEEDBACK_MS);
      } else {
        setTimeout(()=> { renderCurrentQuestion(); timeLeft = computeTimeLeftFromAttempt(attemptData); if(timeLeft<=0) timeLeft=1; startTimer(); }, TIMEOUT_FEEDBACK_MS);
      }
    }

    endBtn.addEventListener('click', async () => {
      if(!attemptRef) return; if(!confirm('End quiz early? This will save your current score.')) return;
      try { await updateDoc(attemptRef, { status:'completed', completedAt: serverTimestamp() }); const s = await getDoc(attemptRef); attemptData = s.data(); showFinal(); } catch(e){ console.error('end early failed', e); alert('Failed to end early'); }
    });

    function showFinal(){
      clearInterval(timer); quizCard.classList.add('hidden'); resultCard.classList.remove('hidden');
      finalSummary.innerHTML = `<div style="font-weight:800">Your score: ${attemptData ? attemptData.score ?? 0 : 0}</div><div class="muted small" style="margin-top:8px">Thanks for playing.</div>`;
      clearLocalSnapshot();
    }

    closeBtn.addEventListener('click', ()=> resultCard.classList.add('hidden'));

    function localKey(){ return currentUser ? `bw_quiz_snap_${QUIZ_ID}_${currentUser.uid}` : null; }
    function saveLocalSnapshot(){ try { const key = localKey(); if(!key || !attemptData || !attemptRef) return; const payload = { attemptId: attemptRef.id, currentIndex: attemptData.currentIndex, score: attemptData.score, status: attemptData.status, questionTimeLeftMs: attemptData.questionTimeLeftMs, questionTimeLeftUpdatedAtMs: attemptData.questionTimeLeftUpdatedAt && attemptData.questionTimeLeftUpdatedAt.seconds ? attemptData.questionTimeLeftUpdatedAt.seconds*1000 : Date.now() }; localStorage.setItem(key, JSON.stringify(payload)); } catch(e){} }
    function clearLocalSnapshot(){ try { const k = localKey(); if(k) localStorage.removeItem(k); } catch(e){} }

    async function loadAttemptsNote(){ try { if(!currentUser) { attemptsNote.textContent = 'Sign in to track attempts.'; return; } const col = collection(db,'quizAttempts'); const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','completed'), limit(10)); const snaps = await getDocs(q); attemptsNote.textContent = `Completed attempts: ${snaps.size}`; } catch(e){ attemptsNote.textContent = 'Could not load attempts count'; } }

    // init UI
    scoreEl.textContent = '0'; timerEl.textContent = String(TIME_PER_QUESTION); progressEl.textContent = `Question 0 / ${QUESTIONS_COUNT}`; attemptsNote.textContent = 'Sign in to track attempts.';

    // small poll fallback
    (function pollAuth(retries=10, interval=400){ let tries=0; const p = setInterval(()=>{ tries++; if(auth.currentUser) clearInterval(p); if(tries>=retries) clearInterval(p); }, interval); })();

  </script>
</body>
</html>
