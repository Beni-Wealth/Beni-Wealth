<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Quiz (Persistent; No Popup)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-1:#061226; --bg-2:#071a2b; --card:#0f1726; --muted:#9aa4b2; --accent:#7c3aed; --success:#10b981; --danger:#ef4444; --text:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));color:var(--text);-webkit-font-smoothing:antialiased;}
    .wrap{max-width:960px;margin:24px auto;padding:20px}
    .header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .logo{font-weight:800;background:linear-gradient(135deg,#7c3aed,#06b6d4);padding:10px 14px;border-radius:10px;color:#041328}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;margin-top:16px;box-shadow:0 8px 30px rgba(2,6,23,0.5)}
    button{cursor:pointer}
    .btn{padding:10px 14px;border-radius:10px;border:0;background:var(--accent);color:#041328;font-weight:800}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 12px;border-radius:8px}
    .muted{color:var(--muted);font-size:13px}
    .flex{display:flex;gap:12px;align-items:center}
    #questionArea{min-height:220px;display:flex;flex-direction:column;gap:12px}
    .question{font-weight:800;font-size:18px}
    .choices{display:flex;flex-direction:column;gap:8px}
    .choice{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
    .choice.disabled{opacity:0.6;pointer-events:none}
    .choice.correct{border-color:rgba(16,185,129,0.8);background:rgba(16,185,129,0.08)}
    .choice.wrong{border-color:rgba(239,68,68,0.9);background:rgba(239,68,68,0.06)}
    .timer{font-weight:800;font-size:18px}
    .score{font-weight:800}
    .small{font-size:13px;color:var(--muted)}
    pre{white-space:pre-wrap}
    @media (max-width:720px){ .flex{flex-direction:column;align-items:flex-start} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="flex">
        <div class="logo">BW QUIZ</div>
        <div>
          <div style="font-weight:800">Historical Quiz — Persistent</div>
          <div class="small">10 questions • 10 seconds each • +10 / -5 scoring</div>
        </div>
      </div>

      <div class="flex">
        <div id="userInfo" class="small muted">Checking site session…</div>
        <!-- optional sign-out if you want to provide a site sign-out button -->
        <button id="signOutBtn" class="btn-ghost hidden">Sign out (site)</button>
      </div>
    </div>

    <div class="card" id="mainCard" role="main" aria-live="polite">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Quiz: <strong id="quizTitle">historical_001</strong></div>
        <div class="small">Status: <span id="statusText">idle</span></div>
      </div>

      <div style="margin-top:12px" id="controls">
        <label class="small">Quiz ID:</label>
        <input id="quizIdInput" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);background:transparent;color:var(--text)" value="historical_001" />
        <button id="startBtn" class="btn" style="margin-left:8px">Start / Resume</button>
        <span style="margin-left:8px" class="small muted">One completed attempt allowed. Use site auth to sign in.</span>
      </div>

      <div id="questionCard" class="card hidden" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="score">Score: <span id="score">0</span></div>
          <div class="timer">Time left: <span id="timer">10</span>s</div>
        </div>

        <div id="questionArea" style="margin-top:12px">
          <!-- question and choices injected here -->
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
          <div class="small muted" id="progress">Question 0 / 10</div>
          <div>
            <button id="nextBtn" class="btn-ghost hidden">Next</button>
            <button id="endEarlyBtn" class="btn-ghost">End Quiz</button>
          </div>
        </div>
      </div>

      <div id="resultCard" class="card hidden" style="margin-top:12px">
        <div style="font-weight:900;font-size:20px">Quiz complete</div>
        <div style="margin-top:8px" id="finalSummary"></div>
        <div style="margin-top:12px">
          <button id="closeSummary" class="btn">Close</button>
        </div>
      </div>

      <div class="card leaderboard" id="leaderboardCard" style="margin-top:12px">
        <div style="font-weight:800">Leaderboard (Top 10)</div>
        <div id="leaderboardList" style="margin-top:8px" class="small muted">Loading…</div>
      </div>
    </div>

  </div>

  <script type="module">
  // ------------- Firebase setup (Beni-Wealth project) -------------
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
  import {
    getAuth, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence
  } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
  import {
    getFirestore, collection, addDoc, getDoc, updateDoc, getDocs, query, where, orderBy, limit, serverTimestamp
  } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

  const firebaseConfig = {
    apiKey: "AIzaSyCAV9eRR32HjYenJNMv3E-KwR4ubFZrhlo",
    authDomain: "beni-wealth.firebaseapp.com",
    projectId: "beni-wealth",
    storageBucket: "beni-wealth.appspot.com",
    messagingSenderId: "1007146234746",
    appId: "1:1007146234746:web:cf2a4eb57a755999f0598c",
    measurementId: "G-N7S4D0M9CG"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ensure auth persistence (so if other pages sign in, session remains)
  await setPersistence(auth, browserLocalPersistence).catch(()=>{/* ignore */});

  // ------------- UI refs & config -------------
  const userInfo = document.getElementById('userInfo');
  const signOutBtn = document.getElementById('signOutBtn');
  const quizIdInput = document.getElementById('quizIdInput');
  const quizTitleEl = document.getElementById('quizTitle');
  const startBtn = document.getElementById('startBtn');
  const statusText = document.getElementById('statusText');

  const questionCard = document.getElementById('questionCard');
  const questionArea = document.getElementById('questionArea');
  const timerEl = document.getElementById('timer');
  const scoreEl = document.getElementById('score');
  const progressEl = document.getElementById('progress');
  const nextBtn = document.getElementById('nextBtn');
  const endEarlyBtn = document.getElementById('endEarlyBtn');

  const resultCard = document.getElementById('resultCard');
  const finalSummary = document.getElementById('finalSummary');
  const closeSummary = document.getElementById('closeSummary');

  const leaderboardList = document.getElementById('leaderboardList');

  // rules
  const QUESTIONS_COUNT = 10;
  const TIME_PER_QUESTION = 10; // seconds
  const POINTS_CORRECT = 10;
  const POINTS_WRONG = -5;

  let currentUser = null;
  let quizId = quizIdInput.value.trim();
  quizTitleEl.textContent = quizId;

  // runtime state
  let questions = []; // placeholder questions; replace by loading from Firestore when ready
  let attemptDocRef = null;
  let attemptData = null;
  let timer = null;
  let timeLeft = TIME_PER_QUESTION;

  const placeholderQuestions = [
    { id:'q1', text:'Which empire built the city of Timbuktu?', choices:['Mali Empire','Songhai Empire','Ghana Empire','Kanem-Bornu Empire'], answerIndex:0 },
    { id:'q2', text:'Who sailed from Spain and reached the Americas in 1492?', choices:['Ferdinand Magellan','Christopher Columbus','Vasco da Gama','John Cabot'], answerIndex:1 },
    { id:'q3', text:'The Magna Carta was signed in which year?', choices:['1215','1315','1415','1515'], answerIndex:0 },
    { id:'q4', text:'Which revolution began in 1789?', choices:['American Revolution','French Revolution','Russian Revolution','Industrial Revolution'], answerIndex:1 },
    { id:'q5', text:'Who was the first emperor of Rome?', choices:['Julius Caesar','Augustus','Nero','Caligula'], answerIndex:1 },
    { id:'q6', text:'The Berlin Wall fell in which year?', choices:['1987','1989','1991','1993'], answerIndex:1 },
    { id:'q7', text:'Which pharaoh commissioned the Great Pyramid of Giza?', choices:['Tutankhamun','Khufu','Ramses II','Akhenaten'], answerIndex:1 },
    { id:'q8', text:'Who led India to independence in 1947?', choices:['Nehru','Gandhi','Jinnah','Tagore'], answerIndex:1 },
    { id:'q9', text:'The Treaty of Versailles ended which war?', choices:['World War I','World War II','Franco-Prussian War','Crimean War'], answerIndex:0 },
    { id:'q10', text:'Which city was the capital of the Ottoman Empire?', choices:['Istanbul','Ankara','Baghdad','Damascus'], answerIndex:0 }
  ];
  questions = placeholderQuestions.slice();

  // ------------- Auth: rely on site auth session (no popup) -------------
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (!user) {
      userInfo.textContent = 'Not signed in on site';
      signOutBtn.classList.add('hidden');
      statusText.textContent = 'idle';
      // clear any in-memory attempt so user can't resume (they must be signed in on site)
      attemptDocRef = null;
      attemptData = null;
      return;
    }
    // user is signed in on site — use their session
    userInfo.textContent = `${user.displayName || user.email} (${user.email})`;
    signOutBtn.classList.remove('hidden');
    quizId = quizIdInput.value.trim();
    quizTitleEl.textContent = quizId;
    // try to resume any in-progress attempt for this user+quiz
    await loadResumeAttemptForUser();
    await loadLeaderboard(quizId);
  });

  // optional sign-out from site
  signOutBtn.addEventListener('click', async () => {
    try { await signOut(auth); location.reload(); } catch(e){ console.error(e); }
  });

  // ------------- Start / Resume logic -------------
  quizIdInput.addEventListener('change', () => {
    quizId = quizIdInput.value.trim();
    quizTitleEl.textContent = quizId;
    if (currentUser) loadResumeAttemptForUser();
    loadLeaderboard(quizId);
  });

  startBtn.addEventListener('click', async () => {
    if (!currentUser) return alert('You are not signed in on the site. Please sign in on the site and return.');
    // block if completed
    const completed = await userHasCompletedQuiz();
    if (completed) return alert('You have already completed this quiz — only one completed attempt allowed.');
    if (attemptData && attemptData.status === 'in_progress') {
      showQuestionStateFromAttempt();
      return;
    }
    await createNewAttemptAndStart();
  });

  // ------- create new attempt -------
  async function createNewAttemptAndStart(){
    const payload = {
      quizId: quizId,
      userId: currentUser.uid,
      userEmail: currentUser.email,
      currentIndex: 0,
      score: 0,
      status: 'in_progress',
      questionStartAt: serverTimestamp(),
      startedAt: serverTimestamp(),
      answers: []
    };
    try {
      const ref = await addDoc(collection(db,'quizAttempts'), payload);
      attemptDocRef = ref;
      const snap = await getDoc(ref);
      attemptData = snap.data();
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
    } catch (e) {
      console.error('create attempt failed', e);
      alert('Failed to create attempt: ' + (e.message||e));
    }
  }

  // ------- load/resume -------
  async function loadResumeAttemptForUser(){
    statusText.textContent = 'checking…';
    attemptDocRef = null;
    attemptData = null;
    try {
      const attemptsRef = collection(db,'quizAttempts');
      const q = query(attemptsRef, where('quizId','==',quizId), where('userId','==',currentUser.uid), where('status','==','in_progress'), limit(1));
      const snaps = await getDocs(q);
      if (!snaps.empty) {
        const s = snaps.docs[0];
        attemptDocRef = s.ref;
        attemptData = s.data();
        // reconcile expired questions and resume
        await reconcileExpiredQuestionsAndResume();
      } else {
        const completed = await userHasCompletedQuiz();
        statusText.textContent = completed ? 'completed' : 'idle';
      }
    } catch (e) {
      console.error('resume check failed', e);
      statusText.textContent = 'idle';
    }
  }

  async function userHasCompletedQuiz(){
    const attemptsRef = collection(db,'quizAttempts');
    const q = query(attemptsRef, where('quizId','==',quizId), where('userId','==',currentUser.uid), where('status','==','completed'), limit(1));
    const snaps = await getDocs(q);
    return !snaps.empty;
  }

  async function reconcileExpiredQuestionsAndResume(){
    if (!attemptData || !attemptDocRef) return;
    const qsa = attemptData.questionStartAt;
    if (!qsa || !qsa.seconds) {
      await updateDoc(attemptDocRef, { questionStartAt: serverTimestamp() });
      const snap = await getDoc(attemptDocRef);
      attemptData = snap.data();
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
      return;
    }
    const nowSeconds = Math.floor(Date.now() / 1000);
    const startSeconds = qsa.seconds;
    const elapsed = nowSeconds - startSeconds;
    const expiredQuestions = Math.floor(elapsed / TIME_PER_QUESTION);

    if (expiredQuestions <= 0) {
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
      return;
    }

    let newIndex = attemptData.currentIndex + expiredQuestions;
    let newScore = attemptData.score + (expiredQuestions * POINTS_WRONG);
    const answersToAppend = [];
    for (let i = 0; i < expiredQuestions && (attemptData.currentIndex + i) < QUESTIONS_COUNT; i++){
      answersToAppend.push({
        qIndex: attemptData.currentIndex + i,
        selectedIndex: null,
        correct: false,
        timedOut: true,
        ts: serverTimestamp()
      });
    }

    if (newIndex >= QUESTIONS_COUNT) {
      try {
        await updateDoc(attemptDocRef, {
          currentIndex: QUESTIONS_COUNT,
          score: newScore,
          answers: (attemptData.answers || []).concat(answersToAppend),
          status: 'completed',
          completedAt: serverTimestamp()
        });
        const s = await getDoc(attemptDocRef);
        attemptData = s.data();
        statusText.textContent = 'completed';
        showFinalSummary();
        return;
      } catch (e) {
        console.error('finish after expiry failed', e);
        alert('Failed to finalize expired quiz: ' + (e.message||e));
        return;
      }
    }

    try {
      await updateDoc(attemptDocRef, {
        currentIndex: newIndex,
        score: newScore,
        answers: (attemptData.answers || []).concat(answersToAppend),
        questionStartAt: serverTimestamp()
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
    } catch (e) {
      console.error('reconcile update failed', e);
      alert('Failed to update attempt during resume: ' + (e.message||e));
    }
  }

  // ------------- UI & timer (same behavior as before) -------------
  function showQuestionStateFromAttempt(){
    if (!questions || questions.length !== QUESTIONS_COUNT) questions = placeholderQuestions.slice();

    if (!attemptData) return;
    if (attemptData.status === 'completed') {
      showFinalSummary();
      return;
    }
    questionCard.classList.remove('hidden');
    resultCard.classList.add('hidden');
    document.getElementById('controls').classList.add('hidden');

    const idx = attemptData.currentIndex || 0;
    const q = questions[idx];
    renderQuestion(q, idx);

    const qsa = attemptData.questionStartAt;
    let elapsed = 0;
    if (qsa && qsa.seconds) {
      const nowSeconds = Math.floor(Date.now()/1000);
      elapsed = nowSeconds - qsa.seconds;
    }
    timeLeft = TIME_PER_QUESTION - (elapsed % TIME_PER_QUESTION);
    if (timeLeft <= 0) timeLeft = 1;
    startTimerTick();
    scoreEl.textContent = attemptData.score ?? 0;
    progressEl.textContent = `Question ${ (idx + 1) } / ${QUESTIONS_COUNT}`;
  }

  function renderQuestion(q, idx){
    questionArea.innerHTML = '';
    const qEl = document.createElement('div'); qEl.className='question'; qEl.textContent = q.text;
    const choicesEl = document.createElement('div'); choicesEl.className='choices';

    q.choices.forEach((c,i) => {
      const btn = document.createElement('div');
      btn.className = 'choice';
      btn.dataset.index = i;
      btn.textContent = c;
      btn.addEventListener('click', () => handleAnswer(i));
      choicesEl.appendChild(btn);
    });

    questionArea.appendChild(qEl);
    questionArea.appendChild(choicesEl);
    nextBtn.classList.add('hidden');
  }

  function startTimerTick(){
    clearInterval(timer);
    timerEl.textContent = timeLeft;
    timer = setInterval(async () => {
      timeLeft--;
      timerEl.textContent = timeLeft;
      if (timeLeft <= 0) {
        clearInterval(timer);
        await handleTimeoutAndAdvance();
      }
    },1000);
  }

  async function handleAnswer(selectedIndex){
    clearInterval(timer);
    const choiceEls = questionArea.querySelectorAll('.choice');
    choiceEls.forEach(c=>c.classList.add('disabled'));

    const idx = attemptData.currentIndex;
    const q = questions[idx];
    const correct = (selectedIndex === q.answerIndex);
    let newScore = (attemptData.score ?? 0) + (correct ? POINTS_CORRECT : POINTS_WRONG);

    const answerObj = {
      qIndex: idx,
      selectedIndex,
      correct,
      timedOut: false,
      ts: serverTimestamp()
    };

    const willFinish = (idx + 1) >= QUESTIONS_COUNT;

    try {
      await updateDoc(attemptDocRef, {
        score: newScore,
        answers: (attemptData.answers || []).concat([answerObj]),
        currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
        status: willFinish ? 'completed' : 'in_progress',
        questionStartAt: willFinish ? null : serverTimestamp(),
        completedAt: willFinish ? serverTimestamp() : undefined
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      scoreEl.textContent = attemptData.score;
      if (correct) {
        choiceEls[selectedIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.color='var(--success)'; fb.style.fontWeight=700; fb.textContent=`Correct! +${POINTS_CORRECT} points.`; questionArea.appendChild(fb);
      } else {
        choiceEls[selectedIndex].classList.add('wrong');
        if (choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.color='var(--danger)'; fb.style.fontWeight=700; fb.textContent=`Wrong — ${POINTS_WRONG} points. Correct: "${q.choices[q.answerIndex]}"`; questionArea.appendChild(fb);
      }
      if (attemptData.status === 'completed') {
        showFinalSummary();
      } else {
        nextBtn.classList.remove('hidden');
        nextBtn.onclick = () => { showQuestionStateFromAttempt(); };
      }
      await loadLeaderboard(quizId);
    } catch (e) {
      console.error('answer update failed', e);
      alert('Failed to save answer: ' + (e.message||e));
    }
  }

  async function handleTimeoutAndAdvance(){
    const idx = attemptData.currentIndex;
    const q = questions[idx];
    const newScore = (attemptData.score ?? 0) + POINTS_WRONG;
    const answerObj = {
      qIndex: idx,
      selectedIndex: null,
      correct: false,
      timedOut: true,
      ts: serverTimestamp()
    };
    const willFinish = (idx + 1) >= QUESTIONS_COUNT;

    try {
      await updateDoc(attemptDocRef, {
        score: newScore,
        answers: (attemptData.answers || []).concat([answerObj]),
        currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
        status: willFinish ? 'completed' : 'in_progress',
        questionStartAt: willFinish ? null : serverTimestamp(),
        completedAt: willFinish ? serverTimestamp() : undefined
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      scoreEl.textContent = attemptData.score;
      const choiceEls = questionArea.querySelectorAll('.choice');
      if (choiceEls[questions[idx].answerIndex]) choiceEls[questions[idx].answerIndex].classList.add('correct');
      const fb = document.createElement('div'); fb.style.color='var(--danger)'; fb.style.fontWeight=700; fb.textContent=`Time expired — ${POINTS_WRONG} points. Correct: "${q.choices[q.answerIndex]}"`; questionArea.appendChild(fb);
      if (attemptData.status === 'completed') {
        showFinalSummary();
      } else {
        nextBtn.classList.remove('hidden');
        nextBtn.onclick = () => { showQuestionStateFromAttempt(); };
      }
      await loadLeaderboard(quizId);
    } catch (e) {
      console.error('timeout update failed', e);
      alert('Failed to save timeout: ' + (e.message||e));
    }
  }

  endEarlyBtn.addEventListener('click', async () => {
    if (!attemptData || !attemptDocRef) return;
    if (!confirm('End quiz early? This will submit your current score.')) return;
    try {
      await updateDoc(attemptDocRef, { status: 'completed', completedAt: serverTimestamp() });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      showFinalSummary();
      await loadLeaderboard(quizId);
    } catch (e) {
      console.error('end early failed', e);
      alert('Failed to end early: ' + (e.message||e));
    }
  });

  function showFinalSummary(){
    clearInterval(timer);
    questionCard.classList.add('hidden');
    resultCard.classList.remove('hidden');
    statusText.textContent = 'completed';
    finalSummary.innerHTML = `<div style="font-weight:800">Your score: ${attemptData.score ?? 0}</div>
      <div class="small muted" style="margin-top:8px">Quiz completed. Thanks for playing.</div>`;
  }

  closeSummary.addEventListener('click', ()=> {
    resultCard.classList.add('hidden');
    document.getElementById('controls').classList.remove('hidden');
  });

  // Leaderboard
  async function loadLeaderboard(qid){
    leaderboardList.innerHTML = 'Loading…';
    try {
      const attemptsRef = collection(db,'quizAttempts');
      const q = query(attemptsRef, where('quizId','==',qid), where('status','==','completed'), orderBy('score','desc'), limit(10));
      const snaps = await getDocs(q);
      if (snaps.empty) { leaderboardList.innerHTML = '<div class="small muted">No completed attempts yet</div>'; return; }
      const rows = [];
      snaps.forEach(s => {
        const a = s.data();
        const ts = a.completedAt && a.completedAt.seconds ? new Date(a.completedAt.seconds*1000).toLocaleString() : '';
        rows.push(`<div style="padding:8px;border-bottom:1px dashed rgba(255,255,255,0.02)"><strong>${a.userEmail}</strong> — <span style="font-weight:800">${a.score}</span><div class="small muted">${ts}</div></div>`);
      });
      leaderboardList.innerHTML = rows.join('');
    } catch (e) {
      console.error('leaderboard load failed', e);
      leaderboardList.innerHTML = '<div class="small muted">Failed to load leaderboard</div>';
    }
  }

  // initial UI
  scoreEl.textContent = '0';
  timerEl.textContent = String(TIME_PER_QUESTION);
  progressEl.textContent = `Question 0 / ${QUESTIONS_COUNT}`;
  statusText.textContent = 'idle';
  quizTitleEl.textContent = quizId;

  </script>
</body>
</html>
