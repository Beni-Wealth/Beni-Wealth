<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Quiz (Fixed Auth)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-1:#061226; --bg-2:#071a2b; --card:#0f1726; --muted:#9aa4b2; --accent:#7c3aed; --success:#10b981; --danger:#ef4444; --text:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));color:var(--text);-webkit-font-smoothing:antialiased;}
    .wrap{max-width:980px;margin:28px auto;padding:18px}
    .header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .logo{font-weight:800;background:linear-gradient(135deg,#7c3aed,#06b6d4);padding:10px 14px;border-radius:10px;color:#041328}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;margin-top:16px;box-shadow:0 8px 30px rgba(2,6,23,0.5)}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .flex{display:flex;gap:12px;align-items:center}
    .btn{padding:10px 14px;border-radius:10px;border:0;background:var(--accent);color:#041328;font-weight:800;cursor:pointer}
    .btn-ghost{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);cursor:pointer}
    #questionArea{min-height:220px;display:flex;flex-direction:column;gap:12px}
    .question{font-weight:800;font-size:18px}
    .choices{display:flex;flex-direction:column;gap:8px}
    .choice{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
    .choice.disabled{opacity:0.6;pointer-events:none}
    .choice.correct{border-color:rgba(16,185,129,0.8);background:rgba(16,185,129,0.08)}
    .choice.wrong{border-color:rgba(239,68,68,0.9);background:rgba(239,68,68,0.06)}
    pre{white-space:pre-wrap}
    @media (max-width:720px){ .flex{flex-direction:column;align-items:flex-start} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="flex">
        <div class="logo">Beni-Wealth — Quiz</div>
        <div>
          <div style="font-weight:800">Historical Quiz</div>
          <div class="small muted">10 questions • 10s each • +10 / −5 scoring • persistence & resume</div>
        </div>
      </div>

      <div class="flex">
        <div id="userInfo" class="small muted">Checking site auth session…</div>
        <button id="signOutBtn" class="btn-ghost hidden">Sign out (site)</button>
      </div>
    </div>

    <div class="card" id="mainCard" role="main" aria-live="polite">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>Quiz ID: <strong id="quizTitle">historical_001</strong></div>
        <div>Status: <span id="statusText">idle</span></div>
      </div>

      <div style="margin-top:12px" id="controls">
        <label class="small muted">Quiz ID</label>
        <input id="quizIdInput" value="historical_001" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)" />
        <button id="startBtn" class="btn" style="margin-left:8px">Start / Resume</button>
        <span class="small muted" style="margin-left:8px">Sign in on the main site — this page will detect the session automatically.</span>
      </div>

      <div id="questionCard" class="card hidden" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>Score: <strong id="score">0</strong></div>
          <div>Time left: <strong id="timer">10</strong>s</div>
        </div>

        <div id="questionArea" style="margin-top:12px"></div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
          <div class="small muted" id="progress">Question 0 / 10</div>
          <div>
            <button id="nextBtn" class="btn-ghost hidden">Next</button>
            <button id="endEarlyBtn" class="btn-ghost">End Quiz</button>
          </div>
        </div>
      </div>

      <div id="resultCard" class="card hidden" style="margin-top:12px">
        <div style="font-weight:900;font-size:20px">Quiz complete</div>
        <div id="finalSummary" style="margin-top:8px"></div>
        <div style="margin-top:12px">
          <button id="closeSummary" class="btn">Close</button>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="font-weight:800">Leaderboard (Top 10)</div>
        <div id="leaderboardList" class="small muted" style="margin-top:8px">Loading…</div>
      </div>
    </div>
  </div>

  <script type="module">
  // ====== FIXED AUTH: reuse existing Firebase app & auth instance if present =======
  import { initializeApp, getApps, getApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
  import { getAuth, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
  import {
    getFirestore, collection, addDoc, getDoc, getDocs, doc, updateDoc, query, where, orderBy, limit, serverTimestamp
  } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

  // your Beni-Wealth config (same as you provided)
  const firebaseConfig = {
    apiKey: "AIzaSyCAV9eRR32HjYenJNMv3E-KwR4ubFZrhlo",
    authDomain: "beni-wealth.firebaseapp.com",
    projectId: "beni-wealth",
    storageBucket: "beni-wealth.appspot.com",
    messagingSenderId: "1007146234746",
    appId: "1:1007146234746:web:cf2a4eb57a755999f0598c",
    measurementId: "G-N7S4D0M9CG"
  };

  // Reuse existing app if present (prevents multiple app instances and mismatched auth)
  const app = getApps().length ? getApp() : initializeApp(firebaseConfig);

  // Use auth from the same app
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ensure auth persistence (so same-site sessions are used)
  try { await setPersistence(auth, browserLocalPersistence); } catch (e) { /* ignore */ }

  // UI refs
  const userInfo = document.getElementById('userInfo');
  const signOutBtn = document.getElementById('signOutBtn');
  const quizIdInput = document.getElementById('quizIdInput');
  const quizTitleEl = document.getElementById('quizTitle');
  const startBtn = document.getElementById('startBtn');
  const statusText = document.getElementById('statusText');

  const questionCard = document.getElementById('questionCard');
  const questionArea = document.getElementById('questionArea');
  const timerEl = document.getElementById('timer');
  const scoreEl = document.getElementById('score');
  const progressEl = document.getElementById('progress');
  const nextBtn = document.getElementById('nextBtn');
  const endEarlyBtn = document.getElementById('endEarlyBtn');

  const resultCard = document.getElementById('resultCard');
  const finalSummary = document.getElementById('finalSummary');
  const closeSummary = document.getElementById('closeSummary');

  const leaderboardList = document.getElementById('leaderboardList');

  // rules
  const QUESTIONS_COUNT = 10;
  const TIME_PER_QUESTION = 10;
  const POINTS_CORRECT = 10;
  const POINTS_WRONG = -5;

  let currentUser = null;
  let quizId = quizIdInput.value.trim();
  quizTitleEl.textContent = quizId;

  let attemptDocRef = null;
  let attemptData = null;
  let questions = [];
  let timer = null;
  let timeLeft = TIME_PER_QUESTION;

  const placeholderQuestions = [
    { id:'q1', text:'Which empire built the city of Timbuktu?', choices:['Mali Empire','Songhai Empire','Ghana Empire','Kanem-Bornu Empire'], answerIndex:0 },
    { id:'q2', text:'Who sailed from Spain and reached the Americas in 1492?', choices:['Ferdinand Magellan','Christopher Columbus','Vasco da Gama','John Cabot'], answerIndex:1 },
    { id:'q3', text:'The Magna Carta was signed in which year?', choices:['1215','1315','1415','1515'], answerIndex:0 },
    { id:'q4', text:'Which revolution began in 1789?', choices:['American Revolution','French Revolution','Russian Revolution','Industrial Revolution'], answerIndex:1 },
    { id:'q5', text:'Who was the first emperor of Rome?', choices:['Julius Caesar','Augustus','Nero','Caligula'], answerIndex:1 },
    { id:'q6', text:'The Berlin Wall fell in which year?', choices:['1987','1989','1991','1993'], answerIndex:1 },
    { id:'q7', text:'Which pharaoh commissioned the Great Pyramid of Giza?', choices:['Tutankhamun','Khufu','Ramses II','Akhenaten'], answerIndex:1 },
    { id:'q8', text:'Who led India to independence in 1947?', choices:['Nehru','Gandhi','Jinnah','Tagore'], answerIndex:1 },
    { id:'q9', text:'The Treaty of Versailles ended which war?', choices:['World War I','World War II','Franco-Prussian War','Crimean War'], answerIndex:0 },
    { id:'q10', text:'Which city was the capital of the Ottoman Empire?', choices:['Istanbul','Ankara','Baghdad','Damascus'], answerIndex:0 }
  ];
  questions = placeholderQuestions.slice();

  // --- AUTH handling: primary onAuthStateChanged + short polling fallback ---
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (!user) {
      // not signed in yet
      userInfo.textContent = 'Not signed in on site';
      signOutBtn.classList.add('hidden');
      statusText.textContent = 'idle';
      attemptDocRef = null; attemptData = null;
      return;
    }
    // signed in (picked up existing session)
    userInfo.textContent = `${user.displayName || user.email} (${user.email})`;
    signOutBtn.classList.remove('hidden');
    quizId = quizIdInput.value.trim();
    quizTitleEl.textContent = quizId;
    await loadQuestionsForQuiz(quizId);
    await loadResumeAttemptForUser();
    await loadLeaderboard(quizId);
  });

  // Poll fallback: sometimes site signs in *after* this page loads — poll briefly
  (function pollAuthFallback(retries = 10, intervalMs = 500) {
    let attempts = 0;
    const poll = setInterval(() => {
      attempts++;
      if (auth.currentUser) {
        clearInterval(poll);
        // onAuthStateChanged will handle the rest; but also invoke explicitly if needed
        // (defensive) trigger resume
        onAuthStateChanged(auth, () => {});
      } else if (attempts >= retries) {
        clearInterval(poll);
      }
    }, intervalMs);
  })();

  signOutBtn.addEventListener('click', async () => {
    try { await signOut(auth); location.reload(); } catch(e){ console.error(e); }
  });

  // ---------- Load questions (Firestore fallback -> local) ----------
  async function loadQuestionsForQuiz(qid){
    try {
      const qcol = collection(db, 'quizzes', qid, 'questions');
      const q = query(qcol, orderBy('createdAt'), limit(QUESTIONS_COUNT));
      const snaps = await getDocs(q);
      if (!snaps.empty && snaps.size >= QUESTIONS_COUNT) {
        const loaded = [];
        snaps.forEach(s => {
          const d = s.data();
          loaded.push({
            id: s.id,
            text: d.text,
            choices: d.choices,
            answerIndex: typeof d.answerIndex === 'number' ? d.answerIndex : 0
          });
        });
        questions = loaded.slice(0, QUESTIONS_COUNT);
        console.info('Loaded questions from Firestore.');
        return;
      }
    } catch (e) {
      console.warn('Failed loading questions from Firestore:', e);
    }
    questions = placeholderQuestions.slice();
  }

  // ---------- Start/Resume ----------
  quizIdInput.addEventListener('change', async () => {
    quizId = quizIdInput.value.trim();
    quizTitleEl.textContent = quizId;
    if (currentUser) {
      await loadQuestionsForQuiz(quizId);
      await loadResumeAttemptForUser();
      await loadLeaderboard(quizId);
    }
  });

  startBtn.addEventListener('click', async () => {
    if (!currentUser) return alert('You are not signed in on the site. Sign in on the main site and return.');
    const completed = await userHasCompletedQuiz();
    if (completed) return alert('You have already completed this quiz — only one completed attempt allowed.');
    if (attemptData && attemptData.status === 'in_progress') { showQuestionStateFromAttempt(); return; }
    await createNewAttemptAndStart();
  });

  async function userHasCompletedQuiz() {
    const attemptsRef = collection(db, 'quizAttempts');
    const q = query(attemptsRef, where('quizId','==',quizId), where('userId','==',currentUser.uid), where('status','==','completed'), limit(1));
    const snaps = await getDocs(q);
    return !snaps.empty;
  }

  async function createNewAttemptAndStart() {
    const payload = {
      quizId: quizId,
      userId: currentUser.uid,
      userEmail: currentUser.email,
      currentIndex: 0,
      score: 0,
      status: 'in_progress',
      questionStartAt: serverTimestamp(),
      startedAt: serverTimestamp(),
      answers: []
    };
    try {
      const ref = await addDoc(collection(db,'quizAttempts'), payload);
      attemptDocRef = ref;
      const snap = await getDoc(ref);
      attemptData = snap.data();
      statusText.textContent = 'in_progress';
      saveLocalProgress();
      showQuestionStateFromAttempt();
    } catch (e) {
      console.error('create attempt failed', e);
      alert('Failed to create attempt: ' + (e.message || e));
    }
  }

  async function loadResumeAttemptForUser() {
    statusText.textContent = 'checking…';
    attemptDocRef = null; attemptData = null;
    try {
      const attemptsRef = collection(db,'quizAttempts');
      const q = query(attemptsRef, where('quizId','==',quizId), where('userId','==',currentUser.uid), where('status','==','in_progress'), limit(1));
      const snaps = await getDocs(q);
      if (!snaps.empty) {
        const s = snaps.docs[0];
        attemptDocRef = s.ref;
        attemptData = s.data();
        await reconcileExpiredQuestionsAndResume();
      } else {
        const completed = await userHasCompletedQuiz();
        statusText.textContent = completed ? 'completed' : 'idle';
        // attemptData remains null
      }
    } catch (e) {
      console.error('resume check failed', e);
      statusText.textContent = 'idle';
    }
  }

  async function reconcileExpiredQuestionsAndResume() {
    if (!attemptData || !attemptDocRef) return;
    const qsa = attemptData.questionStartAt;
    if (!qsa || !qsa.seconds) {
      await updateDoc(attemptDocRef, { questionStartAt: serverTimestamp() });
      const snap = await getDoc(attemptDocRef);
      attemptData = snap.data();
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
      return;
    }
    const nowSeconds = Math.floor(Date.now()/1000);
    const startSeconds = qsa.seconds;
    const elapsed = nowSeconds - startSeconds;
    const expiredQuestions = Math.floor(elapsed / TIME_PER_QUESTION);

    if (expiredQuestions <= 0) {
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
      return;
    }

    let newIndex = attemptData.currentIndex + expiredQuestions;
    let newScore = (attemptData.score ?? 0) + (expiredQuestions * POINTS_WRONG);
    const answersToAppend = [];
    for (let i = 0; i < expiredQuestions && (attemptData.currentIndex + i) < QUESTIONS_COUNT; i++) {
      answersToAppend.push({
        qIndex: attemptData.currentIndex + i,
        selectedIndex: null,
        correct: false,
        timedOut: true,
        ts: serverTimestamp()
      });
    }

    if (newIndex >= QUESTIONS_COUNT) {
      try {
        await updateDoc(attemptDocRef, {
          currentIndex: QUESTIONS_COUNT,
          score: newScore,
          answers: (attemptData.answers || []).concat(answersToAppend),
          status: 'completed',
          completedAt: serverTimestamp()
        });
        const s = await getDoc(attemptDocRef);
        attemptData = s.data();
        statusText.textContent = 'completed';
        saveLocalProgress();
        showFinalSummary();
        return;
      } catch (e) {
        console.error('finish after expiry failed', e);
        alert('Failed to finalize expired quiz: ' + (e.message || e));
        return;
      }
    }

    try {
      await updateDoc(attemptDocRef, {
        currentIndex: newIndex,
        score: newScore,
        answers: (attemptData.answers || []).concat(answersToAppend),
        questionStartAt: serverTimestamp()
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      statusText.textContent = 'in_progress';
      saveLocalProgress();
      showQuestionStateFromAttempt();
    } catch (e) {
      console.error('reconcile update failed', e);
      alert('Failed to update attempt during resume: ' + (e.message || e));
    }
  }

  // UI & timer & answer handlers (same as previous stable logic)
  function showQuestionStateFromAttempt() {
    if (!questions || questions.length !== QUESTIONS_COUNT) questions = placeholderQuestions.slice();
    if (!attemptData) return;
    if (attemptData.status === 'completed') { showFinalSummary(); return; }

    questionCard.classList.remove('hidden');
    resultCard.classList.add('hidden');
    document.getElementById('controls').classList.add('hidden');

    const idx = attemptData.currentIndex || 0;
    const q = questions[idx];
    renderQuestion(q, idx);

    const qsa = attemptData.questionStartAt;
    let elapsed = 0;
    if (qsa && qsa.seconds) {
      const now = Math.floor(Date.now()/1000);
      elapsed = now - qsa.seconds;
    }
    timeLeft = TIME_PER_QUESTION - (elapsed % TIME_PER_QUESTION);
    if (timeLeft <= 0) timeLeft = 1;
    startTimerTick();
    scoreEl.textContent = attemptData.score ?? 0;
    progressEl.textContent = `Question ${ (idx + 1) } / ${QUESTIONS_COUNT}`;
    saveLocalProgress();
  }

  function renderQuestion(q, idx) {
    questionArea.innerHTML = '';
    const qEl = document.createElement('div'); qEl.className = 'question'; qEl.textContent = q.text;
    const choicesEl = document.createElement('div'); choicesEl.className = 'choices';
    q.choices.forEach((c, i) => {
      const btn = document.createElement('div');
      btn.className = 'choice';
      btn.dataset.index = i;
      btn.textContent = c;
      btn.addEventListener('click', () => handleAnswer(i));
      choicesEl.appendChild(btn);
    });
    questionArea.appendChild(qEl);
    questionArea.appendChild(choicesEl);
    nextBtn.classList.add('hidden');
  }

  function startTimerTick() {
    clearInterval(timer);
    timerEl.textContent = timeLeft;
    timer = setInterval(async () => {
      timeLeft--;
      timerEl.textContent = timeLeft;
      saveLocalProgress();
      if (timeLeft <= 0) {
        clearInterval(timer);
        await handleTimeoutAndAdvance();
      }
    }, 1000);
  }

  async function handleAnswer(selectedIndex) {
    clearInterval(timer);
    const choiceEls = questionArea.querySelectorAll('.choice');
    choiceEls.forEach(c => c.classList.add('disabled'));

    const idx = attemptData.currentIndex;
    const q = questions[idx];
    const correct = (selectedIndex === q.answerIndex);
    const newScore = (attemptData.score ?? 0) + (correct ? POINTS_CORRECT : POINTS_WRONG);

    const answerObj = {
      qIndex: idx,
      selectedIndex,
      correct,
      timedOut: false,
      ts: serverTimestamp()
    };

    const willFinish = (idx + 1) >= QUESTIONS_COUNT;

    try {
      await updateDoc(attemptDocRef, {
        score: newScore,
        answers: (attemptData.answers || []).concat([answerObj]),
        currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
        status: willFinish ? 'completed' : 'in_progress',
        questionStartAt: willFinish ? null : serverTimestamp(),
        completedAt: willFinish ? serverTimestamp() : undefined
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      scoreEl.textContent = attemptData.score;
      if (correct) {
        choiceEls[selectedIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.color = 'var(--success)'; fb.style.fontWeight = 700; fb.textContent = `Correct! +${POINTS_CORRECT} points.`; questionArea.appendChild(fb);
      } else {
        choiceEls[selectedIndex].classList.add('wrong');
        if (choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.color = 'var(--danger)'; fb.style.fontWeight = 700; fb.textContent = `Wrong — ${POINTS_WRONG} points. Correct: "${q.choices[q.answerIndex]}"`; questionArea.appendChild(fb);
      }
      saveLocalProgress();
      if (attemptData.status === 'completed') { await loadLeaderboard(quizId); showFinalSummary(); }
      else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { showQuestionStateFromAttempt(); }; }
    } catch (e) {
      console.error('answer update failed', e);
      alert('Failed to save answer: ' + (e.message || e));
    }
  }

  async function handleTimeoutAndAdvance() {
    const idx = attemptData.currentIndex;
    const q = questions[idx];
    const newScore = (attemptData.score ?? 0) + POINTS_WRONG;
    const answerObj = {
      qIndex: idx,
      selectedIndex: null,
      correct: false,
      timedOut: true,
      ts: serverTimestamp()
    };
    const willFinish = (idx + 1) >= QUESTIONS_COUNT;
    try {
      await updateDoc(attemptDocRef, {
        score: newScore,
        answers: (attemptData.answers || []).concat([answerObj]),
        currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
        status: willFinish ? 'completed' : 'in_progress',
        questionStartAt: willFinish ? null : serverTimestamp(),
        completedAt: willFinish ? serverTimestamp() : undefined
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      scoreEl.textContent = attemptData.score;
      const choiceEls = questionArea.querySelectorAll('.choice');
      if (choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
      const fb = document.createElement('div'); fb.style.color = 'var(--danger)'; fb.style.fontWeight = 700; fb.textContent = `Time expired — ${POINTS_WRONG} points. Correct: "${q.choices[q.answerIndex]}"`; questionArea.appendChild(fb);
      saveLocalProgress();
      if (attemptData.status === 'completed') { await loadLeaderboard(quizId); showFinalSummary(); }
      else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { showQuestionStateFromAttempt(); }; }
    } catch (e) {
      console.error('timeout update failed', e);
      alert('Failed to save timeout: ' + (e.message || e));
    }
  }

  endEarlyBtn.addEventListener('click', async () => {
    if (!attemptData || !attemptDocRef) return;
    if (!confirm('End quiz early? This will submit your current score.')) return;
    try {
      await updateDoc(attemptDocRef, { status: 'completed', completedAt: serverTimestamp() });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      saveLocalProgress();
      await loadLeaderboard(quizId);
      showFinalSummary();
    } catch (e) {
      console.error('end early failed', e);
      alert('Failed to end early: ' + (e.message || e));
    }
  });

  function showFinalSummary() {
    clearInterval(timer);
    questionCard.classList.add('hidden');
    resultCard.classList.remove('hidden');
    statusText.textContent = 'completed';
    finalSummary.innerHTML = `<div style="font-weight:800">Your score: ${attemptData.score ?? 0}</div>
      <div class="small muted" style="margin-top:8px">Quiz completed. Your attempt was saved.</div>`;
    clearLocalProgress();
  }

  closeSummary.addEventListener('click', () => {
    resultCard.classList.add('hidden');
    document.getElementById('controls').classList.remove('hidden');
  });

  async function loadLeaderboard(qid) {
    leaderboardList.innerHTML = 'Loading…';
    try {
      const attemptsRef = collection(db, 'quizAttempts');
      const q = query(attemptsRef, where('quizId','==',qid), where('status','==','completed'), orderBy('score','desc'), limit(10));
      const snaps = await getDocs(q);
      if (snaps.empty) { leaderboardList.innerHTML = '<div class="small muted">No completed attempts yet</div>'; return; }
      const rows = [];
      snaps.forEach(s => {
        const a = s.data();
        const ts = a.completedAt && a.completedAt.seconds ? new Date(a.completedAt.seconds * 1000).toLocaleString() : '';
        rows.push(`<div style="padding:8px;border-bottom:1px dashed rgba(255,255,255,0.02)"><strong>${a.userEmail}</strong> — <span style="font-weight:800">${a.score}</span><div class="small muted">${ts}</div></div>`);
      });
      leaderboardList.innerHTML = rows.join('');
    } catch (e) {
      console.error('leaderboard load failed', e);
      leaderboardList.innerHTML = '<div class="small muted">Failed to load leaderboard</div>';
    }
  }

  // Local helpers
  function localKey() { if (!currentUser) return null; return `bw_quiz_${quizId}_${currentUser.uid}`; }
  function saveLocalProgress() {
    try {
      const key = localKey();
      if (!key || !attemptData) return;
      const payload = {
        attemptId: attemptDocRef ? attemptDocRef.id : null,
        currentIndex: attemptData.currentIndex,
        score: attemptData.score,
        status: attemptData.status,
        questionStartAtMs: attemptData.questionStartAt && attemptData.questionStartAt.seconds ? attemptData.questionStartAt.seconds * 1000 : Date.now(),
        lastSavedAt: Date.now()
      };
      localStorage.setItem(key, JSON.stringify(payload));
    } catch (e) {}
  }
  function clearLocalProgress() { try { const key = localKey(); if (!key) return; localStorage.removeItem(key); } catch(e){} }

  // initial UI
  scoreEl.textContent = '0';
  timerEl.textContent = String(TIME_PER_QUESTION);
  progressEl.textContent = `Question 0 / ${QUESTIONS_COUNT}`;
  statusText.textContent = 'idle';
  quizTitleEl.textContent = quizId;

  // Done.
  </script>
</body>
</html>
