<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Quiz Progress</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600,700&display=swap" rel="stylesheet"/>

   <!-- Poppins -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300,400,600,700&display=swap" rel="stylesheet"/>

  <!-- Favicons & Social preview -->
  <link rel="icon" type="image/png" sizes="32x32" href="https://res.cloudinary.com/dq7fpxfbc/image/upload/v1752962852/file_00000000401861f8bf6acb6d55fcf2bf_g2fcrf.png">
  <meta name="theme-color" content="#2fe0b8">
  
  <style>
    :root{
      --bg-1:#0b0613; --bg-2:#0f0820; --card:rgba(255,255,255,0.03);
      --muted:rgba(255,255,255,0.62); --accent:linear-gradient(90deg,#7a5fff,#35d6b1);
      --bar-bg: rgba(255,255,255,0.04); --bar-fill: linear-gradient(90deg,#35d6b1,#5b3bff);
      --radius:14px; color:#eaf2ff; font-family:'Poppins',system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    }
    html,body{height:100%;margin:0;background: radial-gradient(1000px 600px at 10% 10%, rgba(123,61,255,0.08), transparent), linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--card);}
    .wrap{max-width:920px;margin:28px auto;padding:20px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:16px; padding:18px; border:1px solid rgba(255,255,255,0.02); color:var(--text); box-shadow:0 12px 40px rgba(0,0,0,0.45)}
    .top{display:flex;gap:12px;align-items:center}
    .avatar{width:56px;height:56px;border-radius:12px;display:grid;place-items:center;font-weight:800;background:var(--accent); color:#041219}
    h1{margin:0;font-size:18px}
    .muted{color:var(--muted);font-size:13px}
    .desc{margin-top:12px;color:var(--muted)}
    .progress-wrap{margin-top:18px}
    .bar{height:36px;border-radius:12px;background:var(--bar-bg);overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
    .bar-fill{height:100%;width:0%;background:var(--bar-fill);display:flex;align-items:center;justify-content:center;color:#041219;font-weight:800;transition:width 400ms ease}
    .stats{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
    .btn{padding:10px 14px;border-radius:12px;border:0;background:var(--accent);color:#041219;font-weight:800;cursor:pointer}
    .btn-ghost{padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);cursor:pointer}
    .note{margin-top:12px;font-size:13px;color:var(--muted)}
    .center{display:flex;justify-content:center;align-items:center}
    .hidden{display:none}

    /* history */
    .history{margin-top:18px;display:flex;flex-direction:column;gap:12px}
    .round-card{border-radius:12px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
    .round-head{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .top-list{display:flex;gap:10px;flex-wrap:wrap}
    .top-item{background:rgba(255,255,255,0.02);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-width:140px}
    .small-muted{color:var(--muted);font-size:12px}
    @media(max-width:720px){ .wrap{padding:12px} .top{flex-direction:row;gap:12px} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="progressCard">
      <div class="top">
        <div class="avatar" id="avatar">U</div>
        <div style="flex:1">
          <h1 id="title">Current Affairs Quiz — Progress</h1>
          <div class="muted" id="subtitle">Join the quiz — progress shown as percentage only.</div>
        </div>
        <div style="text-align:right">
          <div class="muted" id="uidline">UID: -</div>
        </div>
      </div>

      <p class="desc">Each join is an entry. Progress is displayed as a percentage (0%–100%). Click <strong>Play</strong> to join — you'll be debited ₦20 and then redirected to the round page.</p>

      <div class="progress-wrap" aria-hidden="false">
        <div class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Quiz progress">
          <div id="barFill" class="bar-fill">0%</div>
        </div>
        <div class="stats" style="justify-content:center;margin-top:10px">
          <div class="muted" id="percentLabel">0%</div>
        </div>
      </div>

      <div style="margin-top:18px;display:flex;gap:12px;align-items:center">
        <button id="playBtn" class="btn">Play (₦20)</button>
        <button id="detailsBtn" class="btn-ghost">Details</button>
        <div style="margin-left:auto" id="statusMsg" class="muted"></div>
      </div>

      <div class="note" id="infoNote">After payment and successful join you will be redirected to the round page automatically.</div>
    </div>

    <!-- Quiz history -->
    <div id="history" class="history" aria-live="polite">
      <div class="muted">Loading quiz history…</div>
    </div>
  </div>

  <script type="module">
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, runTransaction, serverTimestamp, onSnapshot,
      collection, query, where, orderBy, limit, getDocs, setDoc, writeBatch
    } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // same config as your dashboard
    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // UI
    const avatarEl = document.getElementById('avatar');
    const uidline = document.getElementById('uidline');
    const barFill = document.getElementById('barFill');
    const percentLabel = document.getElementById('percentLabel');
    const playBtn = document.getElementById('playBtn');
    const statusMsg = document.getElementById('statusMsg');
    const historyWrap = document.getElementById('history');

    // config (internal cap is 20 but UI displays only percentage)
    const QUIZ_ID = 'current_affairs_001';
    const MAX_PARTICIPANTS = 20;
    const ENTRY_FEE = 20;
    const REDIRECT_PAGE = 'round_1764190775161.html';

    let currentUser = null;
    let processingRound = false;

    function extractBalance(d){
      if(!d || typeof d !== 'object') return null;
      if(typeof d.balance === 'number') return d.balance;
      if(typeof d.walletBalance === 'number') return d.walletBalance;
      if(d.wallet && typeof d.wallet.balance === 'number') return d.wallet.balance;
      if(d.account && typeof d.account.balance === 'number') return d.account.balance;
      const tryFields = ['balance','walletBalance','amount','bal'];
      for(const f of tryFields){
        if(typeof d[f] === 'string'){
          const parsed = Number(String(d[f]).replace(/[^0-9.-]+/g,''));
          if(!isNaN(parsed)) return parsed;
        }
      }
      return null;
    }

    const progressRef = doc(db, 'quizProgress', QUIZ_ID);

    // Listen live progress
    onSnapshot(progressRef, async (snap) => {
      const data = snap.exists() ? (snap.data() || {}) : {};
      const count = Number(data.participantsCount || 0);
      updateProgress(count);

      // If full, finalize and start new round automatically
      if(count >= MAX_PARTICIPANTS){
        try { await finalizeRoundIfNeeded(count); } catch(e){ console.warn('finalizeRoundIfNeeded failed', e); }
      }
    }, (err) => {
      console.warn('progress onSnapshot err', err);
      updateProgress(0);
    });

    // initial load
    (async function loadInitialProgress(){
      try {
        const s = await getDoc(progressRef);
        const cnt = s.exists() ? Number(s.data().participantsCount || 0) : 0;
        updateProgress(cnt);
      } catch(e) {
        console.warn('initial progress read failed', e);
        updateProgress(0);
      }
      subscribeRoundsHistory();
    })();

    function updateProgress(count){
      const pct = Math.min(100, Math.round((count / MAX_PARTICIPANTS) * 100));
      barFill.style.width = pct + '%';
      barFill.textContent = pct + '%';
      percentLabel.textContent = pct + '%';
      if(count >= MAX_PARTICIPANTS){
        playBtn.disabled = true;
        playBtn.textContent = 'Full';
        playBtn.style.opacity = 0.6;
      } else {
        playBtn.disabled = false;
        playBtn.textContent = `Play (₦${ENTRY_FEE})`;
        playBtn.style.opacity = 1;
      }
      const bar = document.querySelector('.bar');
      if(bar) bar.setAttribute('aria-valuenow', String(pct));
    }

    onAuthStateChanged(auth, (user) => {
      currentUser = user;
      if(!user){
        avatarEl.textContent = 'U';
        uidline.textContent = 'UID: -';
      } else {
        avatarEl.textContent = (user.displayName || user.email || 'U')[0].toUpperCase();
        uidline.textContent = `UID: ${user.uid.slice(0,6)}`;
      }
    });

    // JOIN transaction (same logic as before)
    playBtn.addEventListener('click', async () => {
      statusMsg.textContent = '';
      if(!currentUser) return alert('Please sign in on the site before joining.');

      // quick client check
      const pSnapNow = await getDoc(progressRef);
      const currentCount = pSnapNow.exists() ? Number(pSnapNow.data().participantsCount || 0) : 0;
      if(currentCount >= MAX_PARTICIPANTS) { alert('This round is full.'); return; }

      if(!confirm(`Confirm: ₦${ENTRY_FEE} entry fee will be deducted to join this round.`)) return;

      try {
        await runTransaction(db, async (tx) => {
          const uid = currentUser.uid;
          const uRef = doc(db, 'users', uid);
          const bRef = doc(db, 'balances', uid);
          const entryId = `${QUIZ_ID}_${uid}_${Date.now()}`; // unique entry doc
          const entryRef = doc(db, 'quizEntries', entryId);
          const pRef = progressRef;

          // --- ALL READS FIRST ---
          const [entrySnap, uSnap, bSnap, pSnap] = await Promise.all([
            tx.get(entryRef), // unlikely to exist
            tx.get(uRef),
            tx.get(bRef),
            tx.get(pRef)
          ]);

          if(entrySnap.exists()){
            throw new Error('already-joined');
          }

          // resolve balance
          let bal = null;
          if(uSnap.exists()){
            bal = extractBalance(uSnap.data());
          }
          if(bal === null || bal === undefined){
            if(bSnap.exists()){
              const bd = bSnap.data();
              bal = (typeof bd.balance === 'number') ? bd.balance : (typeof bd.amount === 'number' ? bd.amount : null);
            }
          }
          if(bal === null || bal === undefined) bal = 0;

          if(Number(bal) < ENTRY_FEE){
            throw new Error('insufficient-funds');
          }

          const prevCount = pSnap.exists() ? Number(pSnap.data().participantsCount || 0) : 0;
          if(prevCount >= MAX_PARTICIPANTS){
            throw new Error('full');
          }
          const nextCount = Math.min(MAX_PARTICIPANTS, prevCount + 1);

          // --- THEN ALL WRITES ---
          const newBal = Number(bal) - ENTRY_FEE;
          tx.set(uRef, { balance: newBal }, { merge: true });

          tx.set(entryRef, {
            quizId: QUIZ_ID,
            userId: uid,
            displayName: currentUser.displayName || currentUser.email || null,
            joinedAt: serverTimestamp()
          });

          tx.set(pRef, { participantsCount: nextCount }, { merge: true });
        });

        statusMsg.textContent = 'Joined ✔ — redirecting…';
        setTimeout(() => { window.location.href = REDIRECT_PAGE; }, 700);
      } catch (err) {
        console.error('join transaction failed', err);
        const msg = (err && err.message) ? err.message : '';
        if(msg === 'already-joined'){ alert('You have already joined this round.'); return; }
        if(msg === 'insufficient-funds'){ alert('Insufficient balance to join. Please top up.'); return; }
        if(msg === 'full'){ alert('This round became full while we attempted to join.'); return; }
        alert('Could not join: ' + (err.message || err));
      }
    });

    /**********************
     * Finalize round code
     * - creates quizRounds/{roundId}
     * - resets quizProgress participantsCount to 0 (transactionally)
     * - selects most recent entries for this quiz (best-effort)
     * - computes top-3 using entry score fields if available
     * - writes top into round doc and marks entries with roundId via batch
     **********************/
    async function finalizeRoundIfNeeded(observedCount){
      if(processingRound) return;
      processingRound = true;
      try {
        // transaction to create round doc and reset progress (ensures single-writer behavior)
        const roundId = await runTransaction(db, async (tx) => {
          const pSnap = await tx.get(progressRef);
          const cnt = pSnap.exists() ? Number(pSnap.data().participantsCount || 0) : 0;
          if(cnt < MAX_PARTICIPANTS){
            throw new Error('not-full'); // someone else already cleared it
          }
          // new round id
          const rid = `${QUIZ_ID}_r_${Date.now()}`;
          const rRef = doc(db, 'quizRounds', rid);
          tx.set(rRef, {
            quizId: QUIZ_ID,
            roundId: rid,
            participantsCount: cnt,
            status: 'finalizing',
            createdAt: serverTimestamp()
          });
          tx.set(progressRef, { participantsCount: 0 }, { merge: true });
          return rid;
        });

        // After transaction, do best-effort aggregation of the participants and top scores
        try {
          // pick most recent <observedCount> entries for this quiz
          const entriesQ = query(
            collection(db, 'quizEntries'),
            where('quizId', '==', QUIZ_ID),
            orderBy('joinedAt', 'desc'),
            limit(observedCount || MAX_PARTICIPANTS)
          );
          const snap = await getDocs(entriesQ);
          const entries = [];
          snap.forEach(docSnap => {
            const d = docSnap.data() || {};
            entries.push({
              id: docSnap.id,
              userId: d.userId || null,
              displayName: d.displayName || d.userEmail || null,
              score: (typeof d.score === 'number') ? d.score : (typeof d.points === 'number' ? d.points : (typeof d.totalScore === 'number' ? d.totalScore : null)),
              raw: d
            });
          });

          // compute top-3 if scores are present
          const entriesWithScore = entries.filter(e => e.score !== null && e.score !== undefined);
          let top = [];
          if(entriesWithScore.length > 0){
            entriesWithScore.sort((a,b) => b.score - a.score);
            top = entriesWithScore.slice(0,3).map(e => ({ userId: e.userId, displayName: e.displayName || '-', score: e.score }));
          }

          // write updates: set round completed data & mark entries with roundId
          const batch = writeBatch(db);
          const rRef = doc(db, 'quizRounds', roundId);
          const roundUpdate = {
            status: 'completed',
            completedAt: serverTimestamp()
          };
          if(top.length > 0) roundUpdate.top = top;
          batch.set(rRef, roundUpdate, { merge: true });

          // mark the selected entries with roundId (best-effort)
          for(const e of entries){
            const eRef = doc(db, 'quizEntries', e.id);
            batch.set(eRef, { roundId }, { merge: true });
          }
          await batch.commit();
        } catch(e){
          console.warn('post-round aggregation failed', e);
          // still ok — round doc exists, progress reset, we'll show history (maybe without top)
        }

      } catch(e){
        if(e && e.message === 'not-full'){
          // someone else finalized in the meantime
        } else {
          console.error('finalizeRound transaction failed', e);
        }
      } finally {
        processingRound = false;
      }
    }

    /**********************
     * Quiz history rendering
     **********************/
    let roundsUnsub = null;
    function subscribeRoundsHistory(){
      if(roundsUnsub){ try{ roundsUnsub(); }catch(e){}; roundsUnsub = null; }
      const roundsQ = query(
        collection(db, 'quizRounds'),
        where('quizId', '==', QUIZ_ID),
        orderBy('createdAt', 'desc'),
        limit(30)
      );
      roundsUnsub = onSnapshot(roundsQ, snap => {
        const rounds = [];
        snap.forEach(s => rounds.push({ id: s.id, data: s.data() || {} }));
        renderRounds(rounds);
      }, err => {
        console.warn('rounds onSnapshot failed', err);
        historyWrap.innerHTML = '<div class="muted">Could not load history.</div>';
      });
    }

    function renderRounds(rounds){
      if(!rounds || rounds.length === 0){
        historyWrap.innerHTML = '<div class="muted">No previous rounds yet.</div>';
        return;
      }
      historyWrap.innerHTML = '';
      for(const r of rounds){
        const node = createRoundCard(r);
        historyWrap.appendChild(node);
      }
    }

    function createRoundCard(r){
      const wrap = document.createElement('div');
      wrap.className = 'round-card';
      const head = document.createElement('div');
      head.className = 'round-head';
      const title = document.createElement('div');
      title.innerHTML = `<strong>Round:</strong> ${r.data.roundId || r.id}`;
      const meta = document.createElement('div');
      const participants = r.data.participantsCount ?? '-';
      const createdAt = r.data.createdAt && r.data.createdAt.toDate ? r.data.createdAt.toDate().toLocaleString() : (r.data.createdAt ? String(r.data.createdAt) : '-');
      meta.innerHTML = `<div class="small-muted">${participants} players • ${createdAt}</div>`;
      head.appendChild(title); head.appendChild(meta);
      wrap.appendChild(head);

      const desc = document.createElement('div');
      desc.className = 'small-muted';
      desc.textContent = r.data.status ? `Status: ${r.data.status}` : 'Status: -';
      wrap.appendChild(desc);

      const topArea = document.createElement('div');
      topArea.style.marginTop = '8px';
      if(Array.isArray(r.data.top) && r.data.top.length > 0){
        const lbl = document.createElement('div'); lbl.style.fontWeight = '800'; lbl.textContent = 'Top players';
        topArea.appendChild(lbl);
        const list = document.createElement('div'); list.className = 'top-list';
        for(const p of r.data.top){
          const it = document.createElement('div'); it.className = 'top-item';
          it.innerHTML = `<div style="font-weight:800">${p.displayName || p.userId}</div><div class="small-muted">Score: ${p.score}</div><div class="small-muted">ID: ${p.userId}</div>`;
          list.appendChild(it);
        }
        topArea.appendChild(list);
      } else {
        topArea.innerHTML = `<div class="small-muted">Top players: unavailable</div>`;
      }
      wrap.appendChild(topArea);

      return wrap;
    }

    // cleanup on unload
    window.addEventListener('beforeunload', () => {
      if(roundsUnsub){ try{ roundsUnsub(); }catch(e){}; roundsUnsub = null; }
    });
  </script>
</body>
</html>
