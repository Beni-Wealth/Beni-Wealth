<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Quiz (Historical) — Persistent</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-1:#061226; --bg-2:#071a2b; --card:#0f1726; --muted:#9aa4b2; --accent:#7c3aed; --success:#10b981; --danger:#ef4444; --text:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));color:var(--text);-webkit-font-smoothing:antialiased;}
    .wrap{max-width:960px;margin:24px auto;padding:20px}
    .header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .logo{font-weight:800;background:linear-gradient(135deg,#7c3aed,#06b6d4);padding:10px 14px;border-radius:10px;color:#041328}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;margin-top:16px;box-shadow:0 8px 30px rgba(2,6,23,0.5)}
    button{cursor:pointer}
    .btn{padding:10px 14px;border-radius:10px;border:0;background:var(--accent);color:#041328;font-weight:800}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 12px;border-radius:8px}
    .muted{color:var(--muted);font-size:13px}
    .flex{display:flex;gap:12px;align-items:center}
    #questionArea{min-height:220px;display:flex;flex-direction:column;gap:12px}
    .question{font-weight:800;font-size:18px}
    .choices{display:flex;flex-direction:column;gap:8px}
    .choice{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
    .choice.disabled{opacity:0.6;pointer-events:none}
    .choice.correct{border-color:rgba(16,185,129,0.8);background:rgba(16,185,129,0.08)}
    .choice.wrong{border-color:rgba(239,68,68,0.9);background:rgba(239,68,68,0.06)}
    .timer{font-weight:800;font-size:18px}
    .score{font-weight:800}
    .small{font-size:13px;color:var(--muted)}
    pre{white-space:pre-wrap}
    @media (max-width:720px){ .flex{flex-direction:column;align-items:flex-start} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="flex">
        <div class="logo">BW QUIZ</div>
        <div>
          <div style="font-weight:800">Historical Quiz — Persistent</div>
          <div class="small">10 questions • 10 seconds each • +10 / -5 scoring</div>
        </div>
      </div>

      <div class="flex">
        <div id="userInfo" class="small muted">Not signed in</div>
        <button id="signInBtn" class="btn">Sign in (Google)</button>
        <button id="signOutBtn" class="btn-ghost hidden">Sign out</button>
      </div>
    </div>

    <div class="card" id="mainCard" role="main" aria-live="polite">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Quiz: <strong id="quizTitle">historical_001</strong></div>
        <div class="small">Status: <span id="statusText">idle</span></div>
      </div>

      <div style="margin-top:12px" id="controls">
        <label class="small">Quiz ID:</label>
        <input id="quizIdInput" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);background:transparent;color:var(--text)" value="historical_001" />
        <button id="startBtn" class="btn" style="margin-left:8px">Start / Resume</button>
        <span style="margin-left:8px" class="small muted">One completed attempt allowed.</span>
      </div>

      <div id="questionCard" class="card hidden" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="score">Score: <span id="score">0</span></div>
          <div class="timer">Time left: <span id="timer">10</span>s</div>
        </div>

        <div id="questionArea" style="margin-top:12px">
          <!-- question and choices injected here -->
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
          <div class="small muted" id="progress">Question 0 / 10</div>
          <div>
            <button id="nextBtn" class="btn-ghost hidden">Next</button>
            <button id="endEarlyBtn" class="btn-ghost">End Quiz</button>
          </div>
        </div>
      </div>

      <div id="resultCard" class="card hidden" style="margin-top:12px">
        <div style="font-weight:900;font-size:20px">Quiz complete</div>
        <div style="margin-top:8px" id="finalSummary"></div>
        <div style="margin-top:12px">
          <button id="closeSummary" class="btn">Close</button>
        </div>
      </div>

      <div class="card leaderboard" id="leaderboardCard" style="margin-top:12px">
        <div style="font-weight:800">Leaderboard (Top 10)</div>
        <div id="leaderboardList" style="margin-top:8px" class="small muted">Loading…</div>
      </div>
    </div>

  </div>

  <script type="module">
  // ------------- Firebase setup (Beni-Wealth project) -------------
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
  import {
    getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged, setPersistence, browserLocalPersistence
  } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
  import {
    getFirestore, collection, doc, addDoc, setDoc, getDoc, updateDoc, getDocs, query, where, orderBy, limit, serverTimestamp
  } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

  const firebaseConfig = {
    apiKey: "AIzaSyCAV9eRR32HjYenJNMv3E-KwR4ubFZrhlo",
    authDomain: "beni-wealth.firebaseapp.com",
    projectId: "beni-wealth",
    storageBucket: "beni-wealth.appspot.com",
    messagingSenderId: "1007146234746",
    appId: "1:1007146234746:web:cf2a4eb57a755999f0598c",
    measurementId: "G-N7S4D0M9CG"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ensure auth persistence (so session survives refresh)
  await setPersistence(auth, browserLocalPersistence).catch(()=>{/* ignore if fails */});

  // ------------- UI refs & config -------------
  const signInBtn = document.getElementById('signInBtn');
  const signOutBtn = document.getElementById('signOutBtn');
  const userInfo = document.getElementById('userInfo');
  const quizIdInput = document.getElementById('quizIdInput');
  const quizTitleEl = document.getElementById('quizTitle');
  const startBtn = document.getElementById('startBtn');
  const statusText = document.getElementById('statusText');

  const questionCard = document.getElementById('questionCard');
  const questionArea = document.getElementById('questionArea');
  const timerEl = document.getElementById('timer');
  const scoreEl = document.getElementById('score');
  const progressEl = document.getElementById('progress');
  const nextBtn = document.getElementById('nextBtn');
  const endEarlyBtn = document.getElementById('endEarlyBtn');

  const resultCard = document.getElementById('resultCard');
  const finalSummary = document.getElementById('finalSummary');
  const closeSummary = document.getElementById('closeSummary');

  const leaderboardList = document.getElementById('leaderboardList');

  // rules from you
  const QUESTIONS_COUNT = 10;
  const TIME_PER_QUESTION = 10; // seconds
  const POINTS_CORRECT = 10;
  const POINTS_WRONG = -5;
  const allowedAdminEmails = ['beniwealth70@gmail.com','owanaomubo76@gmail.com'];

  let currentUser = null;
  let quizId = quizIdInput.value.trim();
  quizTitleEl.textContent = quizId;

  // In-memory runtime state (kept in sync with Firestore attempt doc)
  let questions = []; // load example local questions — replace with your questions later via admin or Firestore
  let attemptDocRef = null; // Firestore doc ref (object with id and path when created)
  let attemptData = null; // local snapshot of attempt document {userId,quizId,currentIndex,score,status,questionStartAt,answers[...] }
  let timer = null;
  let timeLeft = TIME_PER_QUESTION;

  // sample questions (placeholder) — you will replace these by writing the questions into Firestore or modify this file
  const placeholderQuestions = [
    { id:'q1', text:'Which empire built the city of Timbuktu?', choices:['Mali Empire','Songhai Empire','Ghana Empire','Kanem-Bornu Empire'], answerIndex:0 },
    { id:'q2', text:'Who sailed from Spain and reached the Americas in 1492?', choices:['Ferdinand Magellan','Christopher Columbus','Vasco da Gama','John Cabot'], answerIndex:1 },
    { id:'q3', text:'The Magna Carta was signed in which year?', choices:['1215','1315','1415','1515'], answerIndex:0 },
    { id:'q4', text:'Which revolution began in 1789?', choices:['American Revolution','French Revolution','Russian Revolution','Industrial Revolution'], answerIndex:1 },
    { id:'q5', text:'Who was the first emperor of Rome?', choices:['Julius Caesar','Augustus','Nero','Caligula'], answerIndex:1 },
    { id:'q6', text:'The Berlin Wall fell in which year?', choices:['1987','1989','1991','1993'], answerIndex:1 },
    { id:'q7', text:'Which pharaoh commissioned the Great Pyramid of Giza?', choices:['Tutankhamun','Khufu','Ramses II','Akhenaten'], answerIndex:1 },
    { id:'q8', text:'Who led India to independence in 1947?', choices:['Nehru','Gandhi','Jinnah','Tagore'], answerIndex:1 },
    { id:'q9', text:'The Treaty of Versailles ended which war?', choices:['World War I','World War II','Franco-Prussian War','Crimean War'], answerIndex:0 },
    { id:'q10', text:'Which city was the capital of the Ottoman Empire?', choices:['Istanbul','Ankara','Baghdad','Damascus'], answerIndex:0 }
  ];

  questions = placeholderQuestions.slice();

  // ------------- Auth -------------
  const provider = new GoogleAuthProvider();

  signInBtn.addEventListener('click', async () => {
    try { await signInWithPopup(auth, provider); } catch (e) { alert('Sign in failed: ' + (e.message||e)); }
  });

  signOutBtn.addEventListener('click', async ()=> { try { await signOut(auth); location.reload(); } catch(e){} });

  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (!user) {
      userInfo.textContent = 'Not signed in';
      signInBtn.classList.remove('hidden');
      signOutBtn.classList.add('hidden');
      statusText.textContent = 'idle';
      return;
    }
    userInfo.textContent = `${user.displayName || user.email} (${user.email})`;
    signInBtn.classList.add('hidden');
    signOutBtn.classList.remove('hidden');
    quizId = quizIdInput.value.trim();
    quizTitleEl.textContent = quizId;
    // check for any in-progress attempt for this user+quiz
    await loadResumeAttemptForUser();
    // load leaderboard
    await loadLeaderboard(quizId);
  });

  // ------------- Start / Resume flow -------------
  quizIdInput.addEventListener('change', () => {
    quizId = quizIdInput.value.trim();
    quizTitleEl.textContent = quizId;
    // if signed-in, check for in-progress attempts and leaderboard
    if (currentUser) loadResumeAttemptForUser();
    loadLeaderboard(quizId);
  });

  startBtn.addEventListener('click', async () => {
    if (!currentUser) return alert('Please sign in with Google to start.');
    // check if user already completed this quiz
    const completed = await userHasCompletedQuiz();
    if (completed) return alert('You have already completed this quiz — only one completed attempt allowed.');

    // If there's an in-progress attempt, resume it (loadResumeAttemptForUser already does), otherwise create new attempt
    if (attemptData && attemptData.status === 'in_progress') {
      // resume UI
      showQuestionStateFromAttempt();
      return;
    }

    // create new attempt doc
    await createNewAttemptAndStart();
  });

  // --------- create new attempt doc and start ----------
  async function createNewAttemptAndStart(){
    // prepare attempt object
    const payload = {
      quizId: quizId,
      userId: currentUser.uid,
      userEmail: currentUser.email,
      currentIndex: 0,
      score: 0,
      status: 'in_progress',
      // serverTimestamp for question start
      questionStartAt: serverTimestamp(),
      startedAt: serverTimestamp(),
      answers: [] // will push objects {qIndex, selectedIndex, correct, ts}
    };
    try {
      const ref = await addDoc(collection(db,'quizAttempts'), payload);
      attemptDocRef = ref;
      // refresh local attemptData by reading the doc (so timestamps convert)
      const snap = await getDoc(ref);
      attemptData = snap.exists() ? snap.data() : null;
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
    } catch (e) {
      console.error('create attempt failed', e);
      alert('Failed to create attempt: ' + (e.message||e));
    }
  }

  // --------- load/resume existing in-progress attempt if any ----------
  async function loadResumeAttemptForUser(){
    statusText.textContent = 'checking…';
    attemptDocRef = null;
    attemptData = null;
    try {
      const attemptsRef = collection(db,'quizAttempts');
      const q = query(attemptsRef, where('quizId','==',quizId), where('userId','==',currentUser.uid), where('status','==','in_progress'), limit(1));
      const snaps = await getDocs(q);
      if (!snaps.empty) {
        const s = snaps.docs[0];
        attemptDocRef = s.ref;
        attemptData = s.data();
        // On resume: compute elapsed since questionStartAt and apply expirations if needed
        await reconcileExpiredQuestionsAndResume();
      } else {
        // no in-progress attempt; check if user already completed the quiz (to block new attempt)
        const completed = await userHasCompletedQuiz();
        statusText.textContent = completed ? 'completed' : 'idle';
      }
    } catch (e) {
      console.error('resume check failed', e);
      statusText.textContent = 'idle';
    }
  }

  async function userHasCompletedQuiz(){
    const attemptsRef = collection(db,'quizAttempts');
    const q = query(attemptsRef, where('quizId','==',quizId), where('userId','==',currentUser.uid), where('status','==','completed'), limit(1));
    const snaps = await getDocs(q);
    return !snaps.empty;
  }

  // ---------- reconcile any fully-expired questions since stored questionStartAt ----------
  async function reconcileExpiredQuestionsAndResume(){
    if (!attemptData || !attemptDocRef) return;
    // ensure questionStartAt exists and is a Firestore Timestamp
    const qsa = attemptData.questionStartAt;
    if (!qsa || !qsa.seconds) {
      // if missing, just set a fresh start at now
      await updateDoc(attemptDocRef, { questionStartAt: serverTimestamp() });
      const refreshed = await getDoc(attemptDocRef);
      attemptData = refreshed.data();
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
      return;
    }

    const nowSeconds = Math.floor(Date.now() / 1000);
    const startSeconds = qsa.seconds;
    const elapsed = nowSeconds - startSeconds;
    const expiredQuestions = Math.floor(elapsed / TIME_PER_QUESTION);

    if (expiredQuestions <= 0) {
      // still within current question
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
      return;
    }

    // some questions have fully expired — compute new index and score penalty
    let newIndex = attemptData.currentIndex + expiredQuestions;
    let newScore = attemptData.score + (expiredQuestions * POINTS_WRONG);
    // append placeholder timed-out answers for audit
    const answersToAppend = [];
    for (let i = 0; i < expiredQuestions && (attemptData.currentIndex + i) < QUESTIONS_COUNT; i++){
      const qIndex = attemptData.currentIndex + i;
      answersToAppend.push({
        qIndex,
        selectedIndex: null,
        correct: false,
        timedOut: true,
        ts: serverTimestamp()
      });
    }

    // If we've progressed past the last question -> finish quiz immediately
    if (newIndex >= QUESTIONS_COUNT) {
      // finish: set completed, save penalties and mark completedAt
      try {
        await updateDoc(attemptDocRef, {
          currentIndex: QUESTIONS_COUNT,
          score: newScore,
          answers: (attemptData.answers || []).concat(answersToAppend),
          status: 'completed',
          completedAt: serverTimestamp()
        });
        // load updated doc
        const s = await getDoc(attemptDocRef);
        attemptData = s.data();
        statusText.textContent = 'completed';
        showFinalSummary();
        return;
      } catch (e) {
        console.error('finish after expiry failed', e);
        alert('Failed to finalize expired quiz: ' + (e.message||e));
        return;
      }
    }

    // Otherwise advance to the next live question and reset questionStartAt to now
    try {
      await updateDoc(attemptDocRef, {
        currentIndex: newIndex,
        score: newScore,
        // merge answers array client-side (we concatenate)
        answers: (attemptData.answers || []).concat(answersToAppend),
        questionStartAt: serverTimestamp()
      });
      // refresh local attemptData
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      statusText.textContent = 'in_progress';
      showQuestionStateFromAttempt();
    } catch (e) {
      console.error('reconcile update failed', e);
      alert('Failed to update attempt during resume: ' + (e.message||e));
    }
  }

  // ------------- UI rendering & timer -------------
  function showQuestionStateFromAttempt(){
    // ensure questions exist
    if (!questions || questions.length !== QUESTIONS_COUNT) {
      // If you later put questions in Firestore, load them. For now we use placeholderQuestions.
      questions = placeholderQuestions.slice();
    }

    if (!attemptData) return;
    // if completed
    if (attemptData.status === 'completed') {
      showFinalSummary();
      return;
    }
    // else in_progress
    questionCard.classList.remove('hidden');
    resultCard.classList.add('hidden');
    document.getElementById('controls').classList.add('hidden');

    const idx = attemptData.currentIndex || 0;
    const q = questions[idx];
    renderQuestion(q, idx);

    // compute remaining time using stored questionStartAt
    const qsa = attemptData.questionStartAt;
    let elapsed = 0;
    if (qsa && qsa.seconds) {
      const nowSeconds = Math.floor(Date.now()/1000);
      elapsed = nowSeconds - qsa.seconds;
    }
    timeLeft = TIME_PER_QUESTION - (elapsed % TIME_PER_QUESTION);
    if (timeLeft <= 0) timeLeft = 1; // minimal guard
    startTimerTick();
    scoreEl.textContent = attemptData.score ?? 0;
    progressEl.textContent = `Question ${ (idx + 1) } / ${QUESTIONS_COUNT}`;
  }

  function renderQuestion(q, idx){
    questionArea.innerHTML = '';
    const qEl = document.createElement('div'); qEl.className='question'; qEl.textContent = q.text;
    const choicesEl = document.createElement('div'); choicesEl.className='choices';

    q.choices.forEach((c,i) => {
      const btn = document.createElement('div');
      btn.className = 'choice';
      btn.dataset.index = i;
      btn.textContent = c;
      btn.addEventListener('click', () => handleAnswer(i));
      choicesEl.appendChild(btn);
    });

    questionArea.appendChild(qEl);
    questionArea.appendChild(choicesEl);
    nextBtn.classList.add('hidden');
  }

  function startTimerTick(){
    clearInterval(timer);
    timerEl.textContent = timeLeft;
    timer = setInterval(async () => {
      timeLeft--;
      timerEl.textContent = timeLeft;
      if (timeLeft <= 0) {
        clearInterval(timer);
        // handle timeout: mark as wrong, advance and update Firestore
        await handleTimeoutAndAdvance();
      }
    },1000);
  }

  async function handleAnswer(selectedIndex){
    clearInterval(timer);
    // disable UI choices
    const choiceEls = questionArea.querySelectorAll('.choice');
    choiceEls.forEach(c=>c.classList.add('disabled'));

    const idx = attemptData.currentIndex;
    const q = questions[idx];
    const correct = (selectedIndex === q.answerIndex);

    // local score update
    let newScore = (attemptData.score ?? 0) + (correct ? POINTS_CORRECT : POINTS_WRONG);

    // update Firestore: append answer and advance questionStartAt if not last question
    const answerObj = {
      qIndex: idx,
      selectedIndex,
      correct,
      timedOut: false,
      ts: serverTimestamp()
    };

    // If this was the final question, mark completed
    const willFinish = (idx + 1) >= QUESTIONS_COUNT;

    try {
      await updateDoc(attemptDocRef, {
        score: newScore,
        answers: (attemptData.answers || []).concat([answerObj]),
        currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
        status: willFinish ? 'completed' : 'in_progress',
        questionStartAt: willFinish ? null : serverTimestamp(),
        completedAt: willFinish ? serverTimestamp() : undefined
      });
      // refresh local snapshot
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      scoreEl.textContent = attemptData.score;
      // show immediate feedback in UI
      if (correct) {
        choiceEls[selectedIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.color='var(--success)'; fb.style.fontWeight=700; fb.textContent=`Correct! +${POINTS_CORRECT} points.`; questionArea.appendChild(fb);
      } else {
        choiceEls[selectedIndex].classList.add('wrong');
        if (choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.color='var(--danger)'; fb.style.fontWeight=700; fb.textContent=`Wrong — ${POINTS_WRONG} points. Correct: "${q.choices[q.answerIndex]}"`; questionArea.appendChild(fb);
      }
      // if finished, show summary
      if (attemptData.status === 'completed') {
        showFinalSummary();
      } else {
        // otherwise, wait a second then render next question
        nextBtn.classList.remove('hidden');
        nextBtn.onclick = () => {
          // manually trigger showing next by refreshing attempt data & UI
          showQuestionStateFromAttempt();
        };
      }
      await loadLeaderboard(quizId);
    } catch (e) {
      console.error('answer update failed', e);
      alert('Failed to save answer: ' + (e.message||e));
    }
  }

  async function handleTimeoutAndAdvance(){
    const idx = attemptData.currentIndex;
    const q = questions[idx];
    // apply penalty
    const newScore = (attemptData.score ?? 0) + POINTS_WRONG;
    const answerObj = {
      qIndex: idx,
      selectedIndex: null,
      correct: false,
      timedOut: true,
      ts: serverTimestamp()
    };
    const willFinish = (idx + 1) >= QUESTIONS_COUNT;

    try {
      await updateDoc(attemptDocRef, {
        score: newScore,
        answers: (attemptData.answers || []).concat([answerObj]),
        currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
        status: willFinish ? 'completed' : 'in_progress',
        questionStartAt: willFinish ? null : serverTimestamp(),
        completedAt: willFinish ? serverTimestamp() : undefined
      });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      scoreEl.textContent = attemptData.score;
      // show correct choice and feedback
      const choiceEls = questionArea.querySelectorAll('.choice');
      if (choiceEls[attemptData && questions[idx] ? questions[idx].answerIndex : 0]) {
        choiceEls[questions[idx].answerIndex].classList.add('correct');
      }
      const fb = document.createElement('div'); fb.style.color='var(--danger)'; fb.style.fontWeight=700; fb.textContent=`Time expired — ${POINTS_WRONG} points. Correct: "${q.choices[q.answerIndex]}"`; questionArea.appendChild(fb);

      if (attemptData.status === 'completed') {
        showFinalSummary();
      } else {
        // resume next question UI
        nextBtn.classList.remove('hidden');
        nextBtn.onclick = () => { showQuestionStateFromAttempt(); };
      }
      await loadLeaderboard(quizId);
    } catch (e) {
      console.error('timeout update failed', e);
      alert('Failed to save timeout: ' + (e.message||e));
    }
  }

  // End early: mark current state as completed and save
  endEarlyBtn.addEventListener('click', async () => {
    if (!attemptData || !attemptDocRef) return;
    if (!confirm('End quiz early? This will submit your current score.')) return;
    try {
      await updateDoc(attemptDocRef, { status: 'completed', completedAt: serverTimestamp() });
      const s = await getDoc(attemptDocRef);
      attemptData = s.data();
      showFinalSummary();
      await loadLeaderboard(quizId);
    } catch (e) {
      console.error('end early failed', e);
      alert('Failed to end early: ' + (e.message||e));
    }
  });

  // show final summary UI
  function showFinalSummary(){
    clearInterval(timer);
    questionCard.classList.add('hidden');
    resultCard.classList.remove('hidden');
    statusText.textContent = 'completed';
    finalSummary.innerHTML = `<div style="font-weight:800">Your score: ${attemptData.score ?? 0}</div>
      <div class="small muted" style="margin-top:8px">Quiz completed. Thanks for playing.</div>`;
  }

  closeSummary.addEventListener('click', ()=> {
    resultCard.classList.add('hidden');
    document.getElementById('controls').classList.remove('hidden');
  });

  // ------------- Leaderboard (reads quizAttempts completed only) -------------
  async function loadLeaderboard(qid){
    leaderboardList.innerHTML = 'Loading…';
    try {
      const attemptsRef = collection(db,'quizAttempts');
      const q = query(attemptsRef, where('quizId','==',qid), where('status','==','completed'), orderBy('score','desc'), limit(10));
      const snaps = await getDocs(q);
      if (snaps.empty) { leaderboardList.innerHTML = '<div class="small muted">No completed attempts yet</div>'; return; }
      const rows = [];
      snaps.forEach(s => {
        const a = s.data();
        const ts = a.completedAt && a.completedAt.seconds ? new Date(a.completedAt.seconds*1000).toLocaleString() : '';
        rows.push(`<div style="padding:8px;border-bottom:1px dashed rgba(255,255,255,0.02)"><strong>${a.userEmail}</strong> — <span style="font-weight:800">${a.score}</span><div class="small muted">${ts}</div></div>`);
      });
      leaderboardList.innerHTML = rows.join('');
    } catch (e) {
      console.error('leaderboard load failed', e);
      leaderboardList.innerHTML = '<div class="small muted">Failed to load leaderboard</div>';
    }
  }

  // ------------- initial UI state -------------
  scoreEl.textContent = '0';
  timerEl.textContent = String(TIME_PER_QUESTION);
  progressEl.textContent = `Question 0 / ${QUESTIONS_COUNT}`;
  statusText.textContent = 'idle';
  quizTitleEl.textContent = quizId;

  // If user is already signed in (session persisted), onAuthStateChanged will fire and resume attempt.
  // Otherwise, the user can sign in and resume.
  </script>
</body>
</html>
