<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beni-Wealth — Quiz</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet"/>
  <style>
    :root{
      --bg-1:#0b0613; --bg-2:#0f0820; --panel:rgba(255,255,255,0.03); --muted:rgba(255,255,255,0.62);
      --text:#eaf2ff; --accent-grad:linear-gradient(135deg,#8446ff,#5b3bff 45%,#6ce2c8 100%);
      --success:#10b981; --danger:#ef4444;
      font-family:'Poppins',system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background: radial-gradient(1000px 600px at 10% 10%, rgba(123,61,255,0.10), transparent), linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text);}
    .phone{max-width:420px;width:100%;margin:20px auto;border-radius:20px;padding:18px 18px 120px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 18px 60px rgba(0,0,0,0.6)}
    .top{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    .avatar{width:56px;height:56px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:18px;color:#041219;background:var(--accent-grad)}
    .greeting h2{margin:0;font-size:16px;font-weight:700}
    .greeting p{margin:6px 0 0;color:var(--muted);font-size:12px}
    .asset-card{border-radius:14px;padding:12px;margin-bottom:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid rgba(255,255,255,0.03)}
    .asset-sub{color:var(--muted);font-size:12px}
    .asset-amount{font-size:26px;font-weight:800;margin-top:6px}
    .action-row{display:flex;gap:10px;margin-top:12px}
    .pill{flex:1;padding:10px;border-radius:999px;text-align:center;font-weight:800;cursor:pointer;border:1px solid rgba(255,255,255,0.04)}
    .primary{background:linear-gradient(90deg,#7a5fff,#35d6b1);color:#041219}
    .ghost{background:transparent;color:var(--muted)}
    .card{margin-top:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid rgba(255,255,255,0.02)}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .center{display:flex;align-items:center;justify-content:center}
    .hidden{display:none}
    /* quiz UI */
    .quiz-header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .score{font-weight:800}
    .timer{font-weight:800}
    .question{font-weight:800;font-size:16px;margin-top:12px}
    .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .choice{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
    .choice.disabled{opacity:.6;pointer-events:none}
    .choice.correct{background:rgba(16,185,129,0.08);border-color:rgba(16,185,129,0.6)}
    .choice.wrong{background:rgba(239,68,68,0.06);border-color:rgba(239,68,68,0.8)}
    .btn{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,#7a5fff,#5e47ff);color:#041219;font-weight:800;cursor:pointer}
    .btn-ghost{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);cursor:pointer}
  </style>
</head>
<body>
  <div class="phone" role="main" aria-live="polite">
    <div class="top">
      <div class="avatar" id="avatar">U</div>
      <div class="greeting">
        <h2 id="greeting">Hi, User</h2>
        <p id="uidline">UID: -</p>
      </div>
      <div style="margin-left:auto" class="center">
        <div id="balanceBox" class="muted">Balance: <strong id="balance">—</strong></div>
      </div>
    </div>

    <div class="asset-card">
      <div class="asset-sub">Quiz: <strong id="quizTitle">historical_001</strong></div>
      <div class="asset-amount" id="assetBalance">₦0.00</div>
      <div class="muted small">Entry fee: ₦20 per attempt • 10 questions • 10s each</div>

      <div class="action-row">
        <div id="playBtn" class="pill primary">Play (₦20)</div>
        <div id="rulesBtn" class="pill ghost">Rules</div>
      </div>
    </div>

    <div id="quizCard" class="card hidden" aria-live="polite">
      <div class="quiz-header">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="timer">Time left: <span id="timer">10</span>s</div>
      </div>

      <div id="questionArea"></div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
        <div class="muted small" id="progress">Question 0 / 10</div>
        <div>
          <button id="nextBtn" class="btn-ghost hidden">Next</button>
          <button id="endBtn" class="btn-ghost">End</button>
        </div>
      </div>
    </div>

    <div id="resultCard" class="card hidden">
      <div style="font-weight:900">Quiz complete</div>
      <div id="finalSummary" class="muted small" style="margin-top:8px"></div>
      <div style="margin-top:12px" class="center">
        <button id="closeBtn" class="btn">Close</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="font-weight:800">Leaderboard (Top 10)</div>
      <div id="leaderboard" class="muted small" style="margin-top:8px">Loading…</div>
    </div>
  </div>

  <script type="module">
    // Reuse same firebase app pattern as your dashboard
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, updateDoc, addDoc, collection, getDocs, query, where, orderBy, limit, serverTimestamp, onSnapshot, runTransaction
    } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // Use the same config/keys as your dashboard page (beni-wealths)
    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    try { await setPersistence(auth, browserLocalPersistence); } catch(e){/*ignore*/}

    // UI refs
    const avatarEl = document.getElementById('avatar');
    const greetingEl = document.getElementById('greeting');
    const uidLine = document.getElementById('uidline');
    const balanceBox = document.getElementById('balanceBox');
    const balanceEl = document.getElementById('balance');
    const assetBalance = document.getElementById('assetBalance');
    const playBtn = document.getElementById('playBtn');
    const rulesBtn = document.getElementById('rulesBtn');

    const quizCard = document.getElementById('quizCard');
    const questionArea = document.getElementById('questionArea');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const progressEl = document.getElementById('progress');
    const nextBtn = document.getElementById('nextBtn');
    const endBtn = document.getElementById('endBtn');

    const resultCard = document.getElementById('resultCard');
    const finalSummary = document.getElementById('finalSummary');
    const closeBtn = document.getElementById('closeBtn');

    const leaderboardEl = document.getElementById('leaderboard');
    const quizTitleEl = document.getElementById('quizTitle');

    // quiz rules
    const QUIZ_ID = 'historical_001';
    const QUESTIONS_COUNT = 10;
    const TIME_PER_QUESTION = 10;
    const ENTRY_FEE = 20;
    const POINTS_CORRECT = 10;
    const POINTS_WRONG = -5;

    // runtime
    let currentUser = null;
    let userUnsub = null;
    let attemptRef = null;
    let attemptData = null;
    let questions = [];
    let timer = null;
    let timeLeft = TIME_PER_QUESTION;

    quizTitleEl.textContent = QUIZ_ID;

    // placeholder questions (10)
    const placeholder = [
      { id:'q1', text:'Which empire built the city of Timbuktu?', choices:['Mali Empire','Songhai Empire','Ghana Empire','Kanem-Bornu Empire'], answerIndex:0 },
      { id:'q2', text:'Who sailed from Spain and reached the Americas in 1492?', choices:['Ferdinand Magellan','Christopher Columbus','Vasco da Gama','John Cabot'], answerIndex:1 },
      { id:'q3', text:'The Magna Carta was signed in which year?', choices:['1215','1315','1415','1515'], answerIndex:0 },
      { id:'q4', text:'Which revolution began in 1789?', choices:['American Revolution','French Revolution','Russian Revolution','Industrial Revolution'], answerIndex:1 },
      { id:'q5', text:'Who was the first emperor of Rome?', choices:['Julius Caesar','Augustus','Nero','Caligula'], answerIndex:1 },
      { id:'q6', text:'The Berlin Wall fell in which year?', choices:['1987','1989','1991','1993'], answerIndex:1 },
      { id:'q7', text:'Which pharaoh commissioned the Great Pyramid of Giza?', choices:['Tutankhamun','Khufu','Ramses II','Akhenaten'], answerIndex:1 },
      { id:'q8', text:'Who led India to independence in 1947?', choices:['Nehru','Gandhi','Jinnah','Tagore'], answerIndex:1 },
      { id:'q9', text:'The Treaty of Versailles ended which war?', choices:['World War I','World War II','Franco-Prussian War','Crimean War'], answerIndex:0 },
      { id:'q10', text:'Which city was the capital of the Ottoman Empire?', choices:['Istanbul','Ankara','Baghdad','Damascus'], answerIndex:0 }
    ];
    questions = placeholder.slice();

    // balance extraction helper (same logic as dashboard)
    function extractBalance(d){
      if(!d || typeof d !== 'object') return null;
      if(typeof d.balance === 'number') return d.balance;
      if(typeof d.walletBalance === 'number') return d.walletBalance;
      if(d.wallet && typeof d.wallet.balance === 'number') return d.wallet.balance;
      if(d.account && typeof d.account.balance === 'number') return d.account.balance;
      // try parse string fields
      const tryFields = ['balance','walletBalance','amount','bal'];
      for(const f of tryFields){
        if(typeof d[f] === 'string'){
          const parsed = Number(String(d[f]).replace(/[^0-9.-]+/g,''));
          if(!isNaN(parsed)) return parsed;
        }
      }
      return null;
    }
    function formatNaira(n){ return '₦' + Number(n || 0).toLocaleString('en-NG', {minimumFractionDigits:2, maximumFractionDigits:2}); }

    // monitor auth + user balance like your dashboard
    onAuthStateChanged(auth, async (user) => {
      // clear previous
      if(userUnsub){ try{ userUnsub(); }catch(e){} userUnsub = null; }
      currentUser = user;
      if(!user){
        greetingEl.textContent = 'Hi, User';
        avatarEl.textContent = 'U';
        uidLine.textContent = 'UID: -';
        balanceEl.textContent = '—';
        assetBalance.textContent = formatNaira(0);
        return;
      }
      // show user
      greetingEl.textContent = user.displayName || (user.email ? user.email.split('@')[0] : 'User');
      avatarEl.textContent = (user.displayName || user.email || 'U')[0].toUpperCase();
      uidLine.textContent = 'UID: ' + user.uid.slice(0,6);

      // subscribe to users/{uid}
      const uRef = doc(db, 'users', user.uid);
      userUnsub = onSnapshot(uRef, async (snap) => {
        if(!snap.exists()){
          const fallback = await tryBalanceFallback(user.uid);
          balanceEl.textContent = fallback !== null ? formatNaira(fallback) : '—';
          assetBalance.textContent = fallback !== null ? formatNaira(fallback) : formatNaira(0);
        } else {
          const d = snap.data() || {};
          const bal = extractBalance(d);
          balanceEl.textContent = bal !== null ? formatNaira(bal) : '—';
          assetBalance.textContent = bal !== null ? formatNaira(bal) : formatNaira(0);
        }
      }, (err) => {
        console.warn('balance onSnapshot err', err);
        balanceEl.textContent = '—';
        assetBalance.textContent = formatNaira(0);
      });

      // try to load questions from quizzes/{quizId}/questions if present
      await loadQuestions(QUIZ_ID);
      // load leaderboard
      await loadLeaderboard();
      // check for in-progress attempt and resume if present
      await loadResumeAttempt();
    });

    // fallback balance lookups
    async function tryBalanceFallback(uid){
      try{
        const bRef = doc(db, 'balances', uid);
        const bs = await getDoc(bRef);
        if(bs && bs.exists()){
          const dat = bs.data();
          if(dat && (dat.balance !== undefined || dat.amount !== undefined)) return Number(dat.balance ?? dat.amount ?? 0);
        }
      }catch(e){ console.warn('fallback balances doc failed', e); }
      try{
        const col = collection(db, 'balances');
        const q = query(col, where('userId','==', uid), limit(1));
        const snaps = await getDocs(q);
        if(!snaps.empty){ const d = snaps.docs[0].data(); return Number(d.balance ?? d.amount ?? 0); }
      }catch(e){ console.warn('fallback balances collection failed', e); }
      return null;
    }

    // load questions from Firestore quizzes/{id}/questions (optional)
    async function loadQuestions(qid){
      try{
        const col = collection(db, 'quizzes', qid, 'questions');
        const q = query(col, orderBy('createdAt'), limit(QUESTIONS_COUNT));
        const snaps = await getDocs(q);
        if(!snaps.empty && snaps.size >= QUESTIONS_COUNT){
          const loaded = [];
          snaps.forEach(s => {
            const d = s.data();
            loaded.push({ id: s.id, text: d.text, choices: d.choices, answerIndex: d.answerIndex ?? 0 });
          });
          if(loaded.length >= QUESTIONS_COUNT) { questions = loaded.slice(0, QUESTIONS_COUNT); console.info('questions loaded'); }
        }
      }catch(e){ console.warn('loadQuestions failed', e); }
    }

    // START: play button handler — ask confirmation then run transaction to debit ₦20 and create attempt
    playBtn.addEventListener('click', async () => {
      if(!currentUser) return alert('Sign in on the site first.');
      const completed = await hasCompleted();
      if(completed) return alert('You already completed this quiz (one completed attempt only).');

      const inprogress = await hasInProgress();
      if(inprogress) {
        await loadResumeAttempt();
        showQuizUI();
        return;
      }

      const ok = confirm(`You will be debited ₦${ENTRY_FEE} as entry fee to join this quiz. Proceed?`);
      if(!ok) return;

      try {
        const newAttemptRef = doc(collection(db,'quizAttempts'));
        await runTransaction(db, async (tx) => {
          const uRef = doc(db, 'users', currentUser.uid);
          const uSnap = await tx.get(uRef);
          let currentBal = null;
          if(uSnap.exists()){
            const ud = uSnap.data() || {};
            currentBal = extractBalance(ud);
          } else {
            currentBal = null;
          }
          if(currentBal === null){
            const fb = await tryBalanceFallback(currentUser.uid);
            currentBal = fb !== null ? fb : 0;
          }

          if(Number(currentBal) < ENTRY_FEE){
            throw new Error('insufficient-funds');
          }

          const newBal = Number(currentBal) - ENTRY_FEE;
          tx.set(uRef, { balance: newBal }, { merge: true });

          const payload = {
            quizId: QUIZ_ID,
            userId: currentUser.uid,
            userEmail: currentUser.email,
            currentIndex: 0,
            score: 0,
            status: 'in_progress',
            questionStartAt: serverTimestamp(),
            startedAt: serverTimestamp(),
            answers: [],
            entryFee: ENTRY_FEE
          };
          tx.set(newAttemptRef, payload);
          attemptRef = newAttemptRef;
        });

        const snap = await getDoc(attemptRef);
        attemptData = snap.data();
        statusMessage('in_progress');
        saveLocalAttemptSnapshot();
        showQuizUI();
        await loadLeaderboard();
      } catch (e) {
        if(e && e.message === 'insufficient-funds') return alert('Insufficient balance to join the quiz.');
        console.error('transaction failed', e);
        alert('Could not start quiz: ' + (e.message || e));
      }
    });

    // helper: status text in UI (muted)
    function statusMessage(s){ console.info('status',s); }

    // check completed/in-progress
    async function hasCompleted(){
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','completed'), limit(1));
        const snaps = await getDocs(q);
        return !snaps.empty;
      } catch(e){ console.warn('hasCompleted err', e); return false; }
    }
    async function hasInProgress(){
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','in_progress'), limit(1));
        const snaps = await getDocs(q);
        return !snaps.empty;
      } catch(e){ console.warn('hasInProgress err', e); return false; }
    }

    // load existing in-progress attempt (if any)
    async function loadResumeAttempt(){
      attemptRef = null;
      attemptData = null;
      try {
        const col = collection(db, 'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('userId','==', currentUser.uid), where('status','==','in_progress'), limit(1));
        const snaps = await getDocs(q);
        if(!snaps.empty){
          attemptRef = snaps.docs[0].ref;
          attemptData = snaps.docs[0].data();
          await reconcileExpired();
          showQuizUI();
          return;
        }
      } catch(e){ console.warn('loadResumeAttempt err', e); }
    }

    // reconcile expired questions/time left using server timestamps in attemptData.questionStartAt
    async function reconcileExpired(){
      if(!attemptData || !attemptRef) return;
      const qsa = attemptData.questionStartAt;
      if(!qsa || !qsa.seconds){
        try {
          await updateDoc(attemptRef, { questionStartAt: serverTimestamp() });
          const s = await getDoc(attemptRef); attemptData = s.data();
        } catch(e){ console.warn('reconcile set start failed', e); }
        return;
      }
      const nowSeconds = Math.floor(Date.now()/1000);
      const startSeconds = qsa.seconds;
      const elapsed = nowSeconds - startSeconds;
      const expiredQs = Math.floor(elapsed / TIME_PER_QUESTION);
      if(expiredQs <= 0) return;

      let newIndex = (attemptData.currentIndex || 0) + expiredQs;
      let newScore = (attemptData.score || 0) + (expiredQs * POINTS_WRONG);
      const answers = attemptData.answers ? Array.from(attemptData.answers) : [];
      const nowIso = new Date().toISOString();
      for(let i=0;i<expiredQs && (attemptData.currentIndex + i) < QUESTIONS_COUNT;i++){
        answers.push({
          qIndex: attemptData.currentIndex + i,
          selectedIndex: null,
          correct: false,
          timedOut: true,
          ts: nowIso
        });
      }

      if(newIndex >= QUESTIONS_COUNT){
        await updateDoc(attemptRef, {
          currentIndex: QUESTIONS_COUNT,
          score: newScore,
          answers,
          status: 'completed',
          completedAt: serverTimestamp()
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        showFinal();
        return;
      } else {
        await updateDoc(attemptRef, {
          currentIndex: newIndex,
          score: newScore,
          answers,
          questionStartAt: serverTimestamp()
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
      }
    }

    // show UI for quiz and start timer
    function showQuizUI(){
      if(!attemptData) return;
      quizCard.classList.remove('hidden');
      resultCard.classList.add('hidden');
      renderCurrentQuestion();
      const qsa = attemptData.questionStartAt;
      let elapsed = 0;
      if(qsa && qsa.seconds) { elapsed = Math.floor(Date.now()/1000) - qsa.seconds; }
      timeLeft = TIME_PER_QUESTION - (elapsed % TIME_PER_QUESTION);
      if(timeLeft <= 0) timeLeft = 1;
      startTimer();
      loadLeaderboard();
    }

    function renderCurrentQuestion(){
      const idx = attemptData.currentIndex || 0;
      if(idx >= QUESTIONS_COUNT){ showFinal(); return; }
      const q = questions[idx];
      questionArea.innerHTML = `<div class="question">${q.text}</div>`;
      const choicesWrap = document.createElement('div'); choicesWrap.className = 'choices';
      q.choices.forEach((c,i) => {
        const el = document.createElement('div');
        el.className = 'choice';
        el.textContent = c;
        el.dataset.index = i;
        el.addEventListener('click', () => answerChoice(i));
        choicesWrap.appendChild(el);
      });
      questionArea.appendChild(choicesWrap);
      scoreEl.textContent = attemptData.score ?? 0;
      progressEl.textContent = `Question ${ (idx+1) } / ${QUESTIONS_COUNT}`;
      nextBtn.classList.add('hidden');
    }

    function startTimer(){
      clearInterval(timer);
      timerEl.textContent = timeLeft;
      timer = setInterval(async () => {
        timeLeft--;
        timerEl.textContent = timeLeft;
        if(timeLeft <= 0){
          clearInterval(timer);
          await handleTimeout();
        }
      },1000);
    }

    async function answerChoice(selectedIndex){
      clearInterval(timer);
      const idx = attemptData.currentIndex || 0;
      const q = questions[idx];
      const correct = selectedIndex === q.answerIndex;
      const newScore = (attemptData.score || 0) + (correct ? POINTS_CORRECT : POINTS_WRONG);
      const nowIso = new Date().toISOString();
      const answerObj = { qIndex: idx, selectedIndex, correct, timedOut: false, ts: nowIso };
      const willFinish = (idx + 1) >= QUESTIONS_COUNT;
      try {
        await updateDoc(attemptRef, {
          score: newScore,
          answers: (attemptData.answers || []).concat([answerObj]),
          currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
          status: willFinish ? 'completed' : 'in_progress',
          questionStartAt: willFinish ? null : serverTimestamp(),
          completedAt: willFinish ? serverTimestamp() : undefined
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        const choiceEls = questionArea.querySelectorAll('.choice');
        choiceEls.forEach(c => c.classList.add('disabled'));
        if(choiceEls[selectedIndex]) choiceEls[selectedIndex].classList.add(correct ? 'correct' : 'wrong');
        if(!correct && choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.marginTop='8px'; fb.style.fontWeight=700;
        fb.style.color = correct ? 'var(--success)' : 'var(--danger)';
        fb.textContent = correct ? `Correct! +${POINTS_CORRECT}` : `Wrong — ${POINTS_WRONG}. Correct: ${q.choices[q.answerIndex]}`;
        questionArea.appendChild(fb);
        scoreEl.textContent = attemptData.score;
        if(attemptData.status === 'completed'){ showFinal(); await loadLeaderboard(); }
        else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { renderCurrentQuestion(); }; }
      } catch(e){
        console.error('answer failed', e);
        alert('Could not submit answer: ' + (e.message || e));
      }
    }

    async function handleTimeout(){
      const idx = attemptData.currentIndex || 0;
      const q = questions[idx];
      const newScore = (attemptData.score || 0) + POINTS_WRONG;
      const nowIso = new Date().toISOString();
      const answerObj = { qIndex: idx, selectedIndex: null, correct: false, timedOut: true, ts: nowIso };
      const willFinish = (idx + 1) >= QUESTIONS_COUNT;
      try {
        await updateDoc(attemptRef, {
          score: newScore,
          answers: (attemptData.answers || []).concat([answerObj]),
          currentIndex: willFinish ? QUESTIONS_COUNT : (idx + 1),
          status: willFinish ? 'completed' : 'in_progress',
          questionStartAt: willFinish ? null : serverTimestamp(),
          completedAt: willFinish ? serverTimestamp() : undefined
        });
        const s = await getDoc(attemptRef); attemptData = s.data();
        const choiceEls = questionArea.querySelectorAll('.choice');
        if(choiceEls[q.answerIndex]) choiceEls[q.answerIndex].classList.add('correct');
        const fb = document.createElement('div'); fb.style.marginTop='8px'; fb.style.fontWeight=700; fb.style.color='var(--danger)';
        fb.textContent = `Time expired — ${POINTS_WRONG}. Correct: ${q.choices[q.answerIndex]}`;
        questionArea.appendChild(fb);
        scoreEl.textContent = attemptData.score;
        if(attemptData.status === 'completed'){ showFinal(); await loadLeaderboard(); }
        else { nextBtn.classList.remove('hidden'); nextBtn.onclick = () => { renderCurrentQuestion(); }; }
      } catch(e){ console.error('timeout update failed', e); alert('Failed to register timeout: ' + (e.message || e)); }
    }

    // end early
    endBtn.addEventListener('click', async () => {
      if(!attemptRef) return;
      if(!confirm('End quiz early? This will save your current score.')) return;
      try {
        await updateDoc(attemptRef, { status:'completed', completedAt: serverTimestamp() });
        const s = await getDoc(attemptRef); attemptData = s.data();
        showFinal();
        await loadLeaderboard();
      } catch(e){ console.error('end early failed', e); alert('Failed to end early'); }
    });

    function showFinal(){
      clearInterval(timer);
      quizCard.classList.add('hidden');
      resultCard.classList.remove('hidden');
      finalSummary.innerHTML = `<div style="font-weight:800">Your score: ${attemptData.score ?? 0}</div><div class="muted small" style="margin-top:8px">Thanks for playing.</div>`;
      clearLocalAttempt();
    }

    closeBtn.addEventListener('click', () => {
      resultCard.classList.add('hidden');
    });

    // leaderboard loader
    async function loadLeaderboard(){
      try {
        const col = collection(db,'quizAttempts');
        const q = query(col, where('quizId','==', QUIZ_ID), where('status','==','completed'), orderBy('score','desc'), limit(10));
        const snaps = await getDocs(q);
        if(snaps.empty){ leaderboardEl.innerHTML = '<div class="muted small">No completed attempts yet</div>'; return; }
        const rows = [];
        snaps.forEach(s => {
          const a = s.data();
          const ts = a.completedAt && a.completedAt.seconds ? new Date(a.completedAt.seconds*1000).toLocaleString() : '';
          rows.push(`<div style="padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03)"><strong>${a.userEmail}</strong> — <span style="font-weight:800">${a.score}</span><div class="muted small">${ts}</div></div>`);
        });
        leaderboardEl.innerHTML = rows.join('');
      } catch(e){ console.warn('leaderboard failed', e); leaderboardEl.innerHTML = '<div class="muted small">Failed to load leaderboard</div>'; }
    }

    // local snapshot (lightweight) to aid UI resume quickly
    function localKey(){ return currentUser ? `bw_quiz_${QUIZ_ID}_${currentUser.uid}` : null; }
    function saveLocalAttemptSnapshot(){
      try {
        const key = localKey(); if(!key || !attemptData || !attemptRef) return;
        const payload = { attemptId: attemptRef.id, currentIndex: attemptData.currentIndex, score: attemptData.score, status: attemptData.status, questionStartAtMs: attemptData.questionStartAt && attemptData.questionStartAt.seconds ? attemptData.questionStartAt.seconds*1000 : Date.now() };
        localStorage.setItem(key, JSON.stringify(payload));
      } catch(e){}
    }
    function clearLocalAttempt(){ try{ const k = localKey(); if(k) localStorage.removeItem(k); }catch(e){} }

    // initial state
    scoreEl.textContent = '0'; timerEl.textContent = String(TIME_PER_QUESTION);

    // small poll fallback in case auth registers after page load (site signs in shortly)
    (function pollAuth(retries=10, interval=400){
      let tries=0; const p = setInterval(()=>{ tries++; if(auth.currentUser) clearInterval(p); if(tries>=retries) clearInterval(p); }, interval);
    })();

  </script>
</body>
</html>
