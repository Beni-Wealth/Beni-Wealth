<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>My Submissions — Beni-Wealth (Debug)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300,400,600,700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#060511; --bg2:#0f0920;
      --muted: rgba(255,255,255,0.65);
      --text: #eaf2ff;
      --accent-start:#2fe0b8; --accent-end:#7a5fff;
      --card: rgba(255,255,255,0.02);
      --radius:12px; --max-width:1100px;
    }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;font-family:'Poppins',sans-serif;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text);-webkit-font-smoothing:antialiased}
    .shell{max-width:var(--max-width);margin:24px auto;padding:20px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px}
    .brand{font-weight:700;font-size:1.1rem}
    .back{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.03);text-decoration:none;color:var(--text)}
    .muted{color:var(--muted);font-size:13px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:14px}
    .search{flex:1;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
    .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;background:linear-gradient(90deg,var(--accent-start),var(--accent-end));color:#041219;font-weight:700}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .list{display:flex;flex-direction:column;gap:12px}
    .item{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.04);display:grid;grid-template-columns:1fr 220px;gap:12px;align-items:center}
    .item .meta{color:var(--muted);font-size:13px}
    .item .title{font-weight:700;margin-bottom:6px}
    .item .proof{white-space:pre-wrap;color:var(--muted);margin-top:6px}
    .thumb{width:180px;height:100px;object-fit:cover;border-radius:8px;cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
    .status{font-weight:700;padding:6px 10px;border-radius:999px;font-size:13px;text-align:center}
    .status.pending{background:#fff6d6;color:#6a4f00}
    .status.approved{background:#bff0d9;color:#05461f}
    .status.rejected{background:#ffdede;color:#6b0b0b}
    .small{font-size:13px;color:var(--muted)}
    .empty{padding:40px;text-align:center;color:var(--muted)}
    .errorBox{background:#2b0b0f;color:#ffdede;padding:12px;border-radius:10px;margin-bottom:12px;border:1px solid rgba(255,0,0,0.08)}
    /* viewer overlay */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.75);z-index:999;padding:18px}
    .panel{width:100%;max-width:920px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 30px 120px rgba(0,0,0,0.8);}
    .panel h2{margin:0 0 8px 0}
    .closeX{float:right;background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    img.viewerImg{max-width:100%;display:block;margin:12px 0;border-radius:8px}
    @media(max-width:820px){ .item{grid-template-columns:1fr} .thumb{width:100%;height:160px} }
  </style>
</head>
<body>
  <main class="shell">
    <header>
      <a class="back" href="dashboard.html">← Back</a>
      <div style="text-align:right">
        <div class="brand">My Task Submissions</div>
        <div class="muted">All proofs you submitted and their review status</div>
      </div>
    </header>

    <div id="diag" aria-live="polite"></div>

    <section class="controls">
      <input id="search" class="search" placeholder="Search by advert title, status or id" />
      <button id="refresh" class="btn ghost">Refresh</button>
    </section>

    <section id="list" class="list" aria-live="polite">
      <div class="empty">Loading your submissions…</div>
    </section>
  </main>

  <!-- overlay for image / full detail -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="panel" role="dialog" aria-modal="true">
      <button id="closeOverlay" class="closeX" aria-label="Close">✕</button>
      <div id="overlayContent"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
    import {
      getFirestore, collection, query, where, orderBy,
      onSnapshot, getDoc, doc, getDocs
    } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';

    const firebaseConfig = {
      apiKey: "AIzaSyDy_L7uJeoaWXbUB-LVk_fBv8yHeRjNjZk",
      authDomain: "beni-wealths.firebaseapp.com",
      projectId: "beni-wealths",
      storageBucket: "beni-wealths.firebasestorage.app",
      messagingSenderId: "807950483822",
      appId: "1:807950483822:web:e10fa87307e041c4d8417f",
      measurementId: "G-Z2XP3YN6NS"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const diag = document.getElementById('diag');
    const listEl = document.getElementById('list');
    const searchEl = document.getElementById('search');
    const refreshBtn = document.getElementById('refresh');
    const overlay = document.getElementById('overlay');
    const overlayContent = document.getElementById('overlayContent');
    const closeOverlay = document.getElementById('closeOverlay');

    let currentUser = null;
    let unsub = null;
    const advertCache = new Map();
    let submissions = [];

    // candidate collection names to try for submission docs
    const SUB_COLLECTION_CANDIDATES = [
      'advert_submissions','advert_submission','advert-submissions','advert-submits',
      'submissions','task_submissions','advertises_submissions','submission','submits','advert_submission_v2'
    ];

    // candidate advertisement collections (to fetch advert title/thumbnail)
    const AD_COLLECTION_CANDIDATES = [
      'advertise_tasks','advert','adverts','advertise','advertisements','advert_task','tasks','advert_tasks'
    ];

    function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    function niceDate(ts){
      try{
        if(!ts) return '-';
        if (ts.toDate) ts = ts.toDate();
        const d = new Date(ts);
        return d.toLocaleString();
      } catch(e){ return '-' }
    }

    function statusClass(s){
      const st = String(s||'').toLowerCase();
      if(st==='pending') return 'status pending';
      if(st==='approved') return 'status approved';
      if(st==='rejected') return 'status rejected';
      return 'status';
    }

    function renderList(items){
      submissions = items.slice();
      const q = (searchEl.value||'').toLowerCase().trim();
      const filtered = items.filter(it => {
        if(!q) return true;
        return (it.advertTitle||'').toLowerCase().includes(q)
          || (it.status||'').toLowerCase().includes(q)
          || (it.id||'').toLowerCase().includes(q)
          || (it.advertId||'').toLowerCase().includes(q);
      });
      if(!filtered.length){
        listEl.innerHTML = '<div class="empty">No submissions found.</div>';
        return;
      }
      listEl.innerHTML = '';
      filtered.forEach(it => {
        const item = document.createElement('div'); item.className='item';
        const left = document.createElement('div');
        const title = document.createElement('div'); title.className='title'; title.textContent = it.advertTitle || '(no title)';
        const meta = document.createElement('div'); meta.className='meta';
        meta.innerHTML = `Submitted: ${niceDate(it.createdAt)} • Submission ID: <code style="font-family:monospace;color:var(--muted)">${escapeHtml(it.id)}</code>`;
        const proof = document.createElement('div'); proof.className='proof'; proof.textContent = it.textProof || '';
        left.appendChild(title); left.appendChild(meta); left.appendChild(proof);

        const right = document.createElement('div'); right.style.textAlign='right';
        const thumb = document.createElement('img'); thumb.className='thumb';
        if(it.imageUrl){
          thumb.src = it.imageUrl;
          thumb.addEventListener('click', ()=> showOverlayFull(it));
        } else {
          thumb.style.display='none';
        }
        const status = document.createElement('div'); status.className = statusClass(it.status); status.textContent = String(it.status||'pending').toUpperCase();
        const advertId = document.createElement('div'); advertId.className='small'; advertId.style.marginTop='8px';
        advertId.innerHTML = `Advert ID: <code style="font-family:monospace;color:var(--muted)">${escapeHtml(it.advertId)}</code>`;
        right.appendChild(thumb); right.appendChild(status); right.appendChild(advertId);

        item.appendChild(left); item.appendChild(right);
        listEl.appendChild(item);
      });
    }

    function showOverlayFull(item){
      overlayContent.innerHTML = '';
      const h = document.createElement('h2'); h.textContent = item.advertTitle || '(no title)';
      const p1 = document.createElement('div'); p1.className='small'; p1.textContent = `Submission ID: ${item.id} • Advert ID: ${item.advertId} • Submitted: ${niceDate(item.createdAt)}`;
      const st = document.createElement('div'); st.style.marginTop='8px'; st.innerHTML = `Status: <strong>${escapeHtml(item.status||'pending')}</strong>`;
      const txt = document.createElement('div'); txt.style.marginTop='12px'; txt.className='small'; txt.textContent = item.textProof || '(no text proof)';
      overlayContent.appendChild(h); overlayContent.appendChild(p1); overlayContent.appendChild(st); overlayContent.appendChild(txt);
      if(item.imageUrl){
        const img = document.createElement('img'); img.className='viewerImg'; img.src = item.imageUrl; overlayContent.appendChild(img);
      }
      overlay.style.display='flex'; overlay.setAttribute('aria-hidden','false');
    }
    closeOverlay.addEventListener('click', ()=>{ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); overlayContent.innerHTML=''; });
    overlay.addEventListener('click', (e)=>{ if(e.target===overlay){ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); overlayContent.innerHTML=''; } });

    // fetch advert metadata from any of the candidate collections
    async function fetchAdvertMeta(aid){
      if(!aid) return { title:'', thumbnail:'' };
      if(advertCache.has(aid)) return advertCache.get(aid);
      for(const col of AD_COLLECTION_CANDIDATES){
        try{
          const ref = doc(db, col, aid);
          const snap = await getDoc(ref);
          if(snap && snap.exists()){
            const d = snap.data() || {};
            const meta = { title: d.title || d.name || d.adTitle || '', thumbnail: d.thumbnail || d.thumb || d.imageUrl || d.image || '' };
            advertCache.set(aid, meta);
            return meta;
          }
        }catch(e){
          console.warn('fetchAdvertMeta try failed for', col, aid, e);
        }
      }
      const fallback = { title:'(task not found)', thumbnail:'' };
      advertCache.set(aid,fallback);
      return fallback;
    }

    // Try to attach an onSnapshot to a queries built for a candidate collection.
    // If that fails, try a one-time getDocs for that collection. Return the first collection that returns data.
    async function tryCollectionsForUserSubmissions(uid){
      const errors = [];
      for(const col of SUB_COLLECTION_CANDIDATES){
        try {
          // Try a realtime snapshot with orderBy(createdAt)
          const qRef = query(collection(db, col), where('userId','==', uid), orderBy('createdAt','desc'));
          try {
            // set up a temporary listener; if it initializes, we keep it and return
            if (unsub) { try { unsub(); } catch(e){}; unsub=null; }
            unsub = onSnapshot(qRef, async (snap) => {
              // collect items and populate advert meta
              const items = [];
              const advertIds = new Set();
              snap.forEach(s => {
                const d = s.data() || {};
                const advertId = d.advertId || d.advertID || d.taskId || d.task_id || '';
                items.push({
                  id: s.id,
                  advertId,
                  textProof: d.textProof || d.text_proof || d.proofText || '',
                  imageUrl: d.imageUrl || d.image_url || d.image || '',
                  status: d.status || 'pending',
                  createdAt: d.createdAt || d.created_at || d.timestamp || null
                });
                if(advertId) advertIds.add(advertId);
              });

              const missing = Array.from(advertIds).filter(a => a && !advertCache.has(a));
              await Promise.all(missing.map(aid => fetchAdvertMeta(aid)));

              items.forEach(it => {
                const cached = advertCache.get(it.advertId) || {};
                it.advertTitle = cached.title || '';
                if(!it.imageUrl && cached.thumbnail) it.imageUrl = cached.thumbnail;
              });

              renderList(items);
            }, (err) => {
              console.warn('Realtime onSnapshot error for collection', col, err);
              // We'll let fallback logic (below) handle it; unsub remains set and will be torn down by fallback if needed
            });

            // If we reach here we attached a listener — return success and note which collection used
            diag.innerHTML = `<div class="small">Using collection <strong>${col}</strong> (realtime)</div>`;
            console.log('Using submissions collection (realtime):', col);
            return { ok:true, collection: col, mode:'realtime' };
          } catch (errSnap) {
            // couldn't attach realtime (index/permission etc.) - try fallback fetch for this col
            console.warn('onSnapshot setup failed for', col, errSnap);
            errors.push({ collection: col, reason: String(errSnap && errSnap.message ? errSnap.message : errSnap) });
            // try one-time fetch without orderBy
            try {
              const qNoOrder = query(collection(db, col), where('userId','==', uid));
              const snapOnce = await getDocs(qNoOrder);
              if (!snapOnce.empty) {
                const items = [];
                const advertIds = new Set();
                snapOnce.forEach(s => {
                  const d = s.data() || {};
                  const advertId = d.advertId || d.advertID || d.taskId || d.task_id || '';
                  items.push({
                    id: s.id,
                    advertId,
                    textProof: d.textProof || d.text_proof || d.proofText || '',
                    imageUrl: d.imageUrl || d.image_url || d.image || '',
                    status: d.status || 'pending',
                    createdAt: d.createdAt || d.created_at || d.timestamp || null
                  });
                  if(advertId) advertIds.add(advertId);
                });
                const missing = Array.from(advertIds).filter(a => a && !advertCache.has(a));
                await Promise.all(missing.map(aid => fetchAdvertMeta(aid)));
                items.forEach(it => {
                  const cached = advertCache.get(it.advertId) || {};
                  it.advertTitle = cached.title || '';
                  if(!it.imageUrl && cached.thumbnail) it.imageUrl = cached.thumbnail;
                });
                // sort client-side by createdAt when possible
                items.sort((a,b)=>{
                  const ta = a.createdAt && a.createdAt.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?Date.parse(a.createdAt):0);
                  const tb = b.createdAt && b.createdAt.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?Date.parse(b.createdAt):0);
                  return tb - ta;
                });
                renderList(items);
                diag.innerHTML = `<div class="small">Using collection <strong>${col}</strong> (one-time fetch, sorted client-side)</div>`;
                console.log('Using submissions collection (one-time):', col);
                return { ok:true, collection: col, mode:'once' };
              } else {
                // try requestedBy fallback for this same col
                const qReq = query(collection(db,col), where('requestedBy','==',uid));
                const snapReq = await getDocs(qReq);
                if(!snapReq.empty){
                  const items = [];
                  const advertIds = new Set();
                  snapReq.forEach(s => {
                    const d = s.data() || {};
                    const advertId = d.advertId || d.advertID || d.taskId || d.task_id || '';
                    items.push({
                      id: s.id,
                      advertId,
                      textProof: d.textProof || d.text_proof || d.proofText || '',
                      imageUrl: d.imageUrl || d.image_url || d.image || '',
                      status: d.status || 'pending',
                      createdAt: d.createdAt || d.created_at || d.timestamp || null
                    });
                    if(advertId) advertIds.add(advertId);
                  });
                  const missing = Array.from(advertIds).filter(a => a && !advertCache.has(a));
                  await Promise.all(missing.map(aid => fetchAdvertMeta(aid)));
                  items.forEach(it => {
                    const cached = advertCache.get(it.advertId) || {};
                    it.advertTitle = cached.title || '';
                    if(!it.imageUrl && cached.thumbnail) it.imageUrl = cached.thumbnail;
                  });
                  items.sort((a,b)=>{
                    const ta = a.createdAt && a.createdAt.toDate ? a.createdAt.toDate().getTime() : (a.createdAt?Date.parse(a.createdAt):0);
                    const tb = b.createdAt && b.createdAt.toDate ? b.createdAt.toDate().getTime() : (b.createdAt?Date.parse(b.createdAt):0);
                    return tb - ta;
                  });
                  renderList(items);
                  diag.innerHTML = `<div class="small">Using collection <strong>${col}</strong> with field <strong>requestedBy</strong> (one-time)</div>`;
                  console.log('Using submissions collection (requestedBy fallback):', col);
                  return { ok:true, collection: col, mode:'once-requestedBy' };
                }
              }
            } catch (errOne) {
              console.warn('One-time fetch failed for', col, errOne);
              errors.push({ collection: col, reason: String(errOne && errOne.message ? errOne.message : errOne) });
            }
          }
        } catch (e) {
          console.warn('Query construction failed for', col, e);
          errors.push({ collection: col, reason: String(e && e.message ? e.message : e) });
        }
      } // end for

      // If we reach here, none of the candidate collections returned data
      const msg = ['Could not find submissions in any candidate collection. Attempts:'];
      errors.forEach(er => msg.push(`${er.collection}: ${er.reason}`));
      return { ok:false, errors };
    }

    async function startListener(uid){
      // teardown previous
      if(unsub){ try{ unsub(); }catch(e){}; unsub = null; }
      listEl.innerHTML = '<div class="empty">Loading your submissions…</div>';
      diag.innerHTML = '';

      const result = await tryCollectionsForUserSubmissions(uid);
      if(!result.ok){
        console.error('All collection attempts failed', result.errors);
        const html = ['<div class="errorBox"><strong>Failed to load submissions</strong><div style="margin-top:8px">I tried multiple collection names but none returned results. Diagnostics (first few):</div><ul style="margin-top:8px">'];
        result.errors.slice(0,6).forEach(er => {
          html.push(`<li><strong>${escapeHtml(er.collection)}</strong>: ${escapeHtml(er.reason)}</li>`);
        });
        html.push('</ul><div style="margin-top:8px" class="small">Suggestions: confirm the collection name in Firestore console, check security rules allow reads for the logged-in user, and ensure ` +
          '`createdAt` is present if you want ordered realtime snapshots. If you want, send me the console error text and I\'ll diagnose.</div></div>');
        diag.innerHTML = html.join('');
        listEl.innerHTML = '<div class="empty">Failed to load submissions.</div>';
      } else {
        // success; note: onSnapshot handler or one-time fetch will have rendered items
        console.log('startListener succeeded with', result);
      }
    }

    onAuthStateChanged(auth, user => {
      currentUser = user;
      if(!user){
        listEl.innerHTML = '<div class="empty">Please sign in to view your submissions.</div>';
        diag.innerHTML = '';
        return;
      }
      startListener(user.uid);
    });

    refreshBtn.addEventListener('click', ()=>{ if(currentUser) startListener(currentUser.uid); });
    searchEl.addEventListener('input', ()=> renderList(submissions));
  </script>
</body>
</html>
